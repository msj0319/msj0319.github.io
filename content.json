{"pages":[{"title":"about","text":"안녕하세요 개발자를 꿈꾸고 있는 문도니입니다.그동안 배워 오고 공부해온 것들을 정리 해야겠다는 생각이 들었어요. 컴퓨터를 전공한 학생들은 과제나 학업을 위해 블로그를 뒤적거리고, 개발자들은 앞에 놓인 문제에 빠르게 대응하기 위해 잘 정리 되어진 블로그를 찾기 마련입니다.길을 잃은 IT인들의 길잡이가 되고 저 또한 제가 닦아 놓은 길을 다시 되돌아 볼 수 있는 곳. 저도 그런 블로그를 만들고 싶어졌어요.학부 4학년을 바라보는 이 시점에서 제가 배운 것은 얼마나 많고, 제 머릿속에서 꺼내 쓸 수 있는 지식들은 얼마나 될지 기록해보고 싶어졌습니다. Career 라온시큐어 인턴 - QA Tester (2019/07 ~ 2020/01) : 전반적인 IT 회사에서의 개발 프로세스 경험.","link":"/about/index.html"}],"posts":[{"title":"[프로그래머스] K번째 수","text":"배열 array를 i번째 부터 j번째 까지 자르고 정렬했을 때, k번째에 있는 수를 구한다. commands 배열의 각 행, 즉 i,j,k를 잘 뽑아내고 정렬 후 k번째 수를 answer 배열에 넣기만 하면 된다. i, j, k 명령 수행 시 k번째 수는 ‘하나’가 나오게 된다. commands의 길이는 1~50 이하 이므로 k번째 수를 담는 answer 배열의 크기는 commands.length 만큼 할당해야 한다. 그리고 i, j, k 값들을 각각 치환하여 사용하기 쉽게 만들었다. 또한 i번째 부터 j번-[ys.copyOfRange() 함수를 사용했다. 말 그대로 구간을 정해 copy하는 함수다. 첫번째 인자부터 배열의 주소(이름), 시작 인덱스, 종료 인덱스(종료 인덱스는 구간에 포함하지 않는다.) 이다. 12int[] array2 = Arrays.copyOfRange(array,i-1,j); // 배열은 0부터 시작하므로 i-1 한다. Arrays.sort() 해주고, k번째 (k-1번째 index) 수를 answer 배열에 넣고 return 해주면 된다. 123456789101112131415161718import java.util.Arrays;class Solution { public int[] solution(int[] array, int[][] commands) { int[] answer = new int[commands.length]; for (int index = 0; index&lt;commands.length; index++){ int i = commands[index][0]; int j = commands[index][1]; int k = commands[index][2]; int[] array2 = Arrays.copyOfRange(array,i-1,j); Arrays.sort(array2); answer[index] = array2[k-1]; } return answer; }}","link":"/2020/01/27/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-K%EB%B2%88%EC%A7%B8-%EC%88%98/"},{"title":"[프로그래머스] 문자열을 정수로 바꾸기","text":"문자열의 길이는(s는) 1~5이고, s 맨 앞에는 부호(+,-)가 올 수 있다고 한다.부호에 따른 처리가 필요한 것인지 궁금했지만 일단 매개변수로 받은 문자열 s를 정수로 casting 해보았다. 123456789import java.util.*;class Solution { public int solution(String s) { int answer = 0; answer = Integer.parseInt(s); return answer; }} 우선 이렇게 코딩 후 실행하니 테스트케이스를 전부 통과했고, 놀랍게도 제출하니 정답으로 통과했다.하지만 남들이 푼 코드를 보니 API에 의존한 내가 너무 부끄럽게 느껴질 정도였다.남들이 푼 코드 중 하나를 가져와서 atoi에 대해 다시 한번 익혀보도록 하자. 12345678910111213141516171819public class Solution { public int solution(String str) { boolean plus = true; int value = 0; for (char ch : str.toCharArray()) { if (ch == '-') { plus = false; } else { int num = ch - 48; value = num+value*10; } } return (plus==true)? value : -1*value; }} 매개변수 문자열 str을 toCharArray로 문자로 char 변수에 받은 후 - 부호가 존재하면 plus 상태를 false라고 해주고 만약 +부호 일때는 if문을 벗어난다.문자 중 부호가 없으면 else 문으로 진입하게 되는데, 여기서부터가 atoi의 핵심이다. 12345678for (char ch : str.toCharArray()) { if (ch == '-') { plus = false; } else { int num = ch - 48; value = num+value*10; } String 객체에 담긴 문자열이 int 형 변수에 Integer로 Casting 되는 과정이다. 123456//ex) String = 12result = 0; //초기값result = (result * 10) + '1' - 48; //1result = (1 * 10) + '2' - 48; //12//result의 최종 결과 값은 12 초반에 result에 10을 곱해주는 이유는 Decimal 데이터를 얻어야 하기에 그렇다.또한 아스키코드 상에서 48은 문자열 0이므로 문자열 1(49)에서 문자열 0(48)을 빼주면 정수 1이 출력될 수 있다. 마지막으로 plus 상태가 true이면 바로 value 출력, false면 value에 -1을 곱한 후 리턴해주면 된다.","link":"/2020/02/06/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%AC%B8%EC%9E%90%EC%97%B4%EC%9D%84-%EC%A0%95%EC%88%98%EB%A1%9C-%EB%B0%94%EA%BE%B8%EA%B8%B0/"},{"title":"[프로그래머스] 문자열 다루기 기본","text":"문자열 다루기 기본 문제라는 문제 이름으로 쉬운 문제라고 생각하고 풀었다. 아스키코드 상으로 알파벳 소문자 또는 대문자가 문자열 안에 존재하면 answer 상태를 false로 바꿔주고 리턴까지 시켰다. 하지만 주어진 테스트 케이스를 통과하였지만 자꾸 테스트 5,6번에서 막혔고 이유가 뭔지 골똘히 생각하던 중에 그 이유를 찾을 수 있었다. 1문자열 s의 길이가 4 혹은 6이고, 숫자로만 구성되어 있는지 확인하는 함수, solution을 완성하세요. 아뿔싸. 문자열 s의 길이가 4또는 6인지 확인하는 구문을 넣지 않았다…해당 문제의 질문하기에는 쉬운 문제임에도 불구하고 많은 사람들이 “왜 테스트케이스 5,6번에서 막히는 거죠?” 라는 바보같은 질문을 올려댔다. 나도 그 이유를 몰라 찾아 해맸고 탄식이 나올 정도로 어이없었다. 다음부턴 입출력만 보고 문제를 푸는 습관은 고쳐야겠다 라는 당연한 생각을 했다. 1234567891011121314151617class Solution { public boolean solution(String s) { boolean answer = true; if (s.length() == 4 || s.length() == 6) { for (int i=0; i&lt;s.length(); i++){ if((65&lt;= s.charAt(i) &amp;&amp; s.charAt(i) &lt;= 90) || (97&lt;= s.charAt(i) &amp;&amp; s.charAt(i) &lt;= 122)){ answer = false; break; } } return answer; } else answer = false; return answer; }}","link":"/2020/02/07/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%8B%A4%EB%A3%A8%EA%B8%B0-%EA%B8%B0%EB%B3%B8/"},{"title":"[프로그래머스] 나머지 한 점","text":"직사각형을 만드는데 필요한 4개의 점 중 3개만 주어질 때, 주어지는 3개의 점들은 모두 각 x축 y축에 평행 하도록 하는 좌표만 주므로, 만약 [[1,4],[3,4],[3,10]] 이 주어졌을 때 중복 되는 배열의 원소 수는 소거한다. 그럼 중복 되지 않는 수가 나머지 한 점 이 된다.그러므로 [1,10] 이 output으로 나와야 한다. 주어진 2차원 배열을 비정방형 행렬로 생각하여 풀어보자. 1234 x좌표 y좌표v = [[1, 4] [0][0] [0][1] [3, 4] == [1][0] [1][1] [3,10]] [2][0] [2][1] 1234567891011121314151617181920212223242526272829class Solution { public int[] solution(int[][] v) { int x, y; // x좌표값 찾기 if (v[0][0]==v[1][0]){ x = v[2][0]; } else if (v[0][0]==v[2][0]){ x = v[1][0]; } else x = v[0][0]; //y좌표값 찾기 if(v[0][1] == v[1][1]){ y = v[2][1]; } else if(v[0][1]==v[2][1]){ y = v[1][1]; } else y = v[0][1]; int[] answer = {x,y}; return answer; }} XOR 연산자 사용하여 문제해결 12345678910111213class Solution { public int[] solution(int[][] v) { int[] answer = {0,0}; //좌표는 총 3개가 입력으로 주어지므로 반복을 3번 돌린다. for (int i=0; i&lt;3; i++){ answer[0] ^= v[i][0]; answer[1] ^= v[i][1]; } return answer; }}","link":"/2020/01/22/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%82%98%EB%A8%B8%EC%A7%80-%ED%95%9C-%EC%A0%90/"},{"title":"[프로그래머스] 자릿 수 더하기","text":"컴퓨터과학 수업에서 새로운 언어를 배울 때 지겹도록 짜본 코드…하지만 간과하지 말자. 이런 간단한 것도 생각이 안날 수 있으니까. 123456789101112import java.util.*;public class Solution { public int solution(int n) { int answer = 0; while (n!=0) { answer += n % 10; n /= 10; } return answer; }}","link":"/2020/01/22/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%9E%90%EB%A6%BF-%EC%88%98-%EB%8D%94%ED%95%98%EA%B8%B0/"},{"title":"[Hexo Blog] Markdown 플러그인 설치","text":"마크다운은 간단한 인라인 코드를 작성할 때 백틱을 이용한다. 1`(넣을 내용)` 근데 잘 쓰고 있던 중 어떤 md 파일은 먹히는데 새로 작성하는 파일에선 되지 않는 현상을 발견했다. 구글링을 통해 삽질을 해본 결과 기본 hexo는 원래 해당 태그를 지원하지 않는다는 사실을 어느 블로그를 통해 알게 되었고 당장 hexo 용 마크다운 플러그인을 설치했다. 참조 : https://d2fault.github.io/2018/07/03/20180703-smart-posting/ Installhttps://github.com/CHENXCHEN/hexo-renderer-markdown-it-plushexo가 설치 된 루트 폴더 (블로그 theme 상단 경로)에 아래 npm 명령을 입력한다. 12npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it-plus --save _config.yml 설정1234567891011#Markdown 플러그인 설치markdown_it_plus: highlight: true html: true xhtmlOut: true breaks: true langPrefix: linkify: true typographer: quotes: “”‘’ pre_class: highlight _config.yml 파일 최하단에 다음 구문을 넣어 설정한다.","link":"/2020/01/28/Hexo-Blog-Markdown-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-%EC%84%A4%EC%B9%98/"},{"title":"[프로그래머스] 직사각형 별 찍기","text":"이중 for문을 잘 이해하라! 12345678910111213141516import java.util.Scanner;public class Solution { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a = sc.nextInt(); int b = sc.nextInt(); for (int i=0; i&lt;b; i++){ for (int j=0; j&lt;a; j++){ System.out.print(\"*\"); } System.out.println(); } }}","link":"/2020/01/26/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%A7%81%EC%82%AC%EA%B0%81%ED%98%95-%EB%B3%84-%EC%B0%8D%EA%B8%B0/"},{"title":"[프로그래머스] 짝수와 홀수","text":"num이 짝수면 Even 홀수면 Odd 123456789101112class Solution { public String solution(int num) { String answer = \"\"; if (num % 2 == 0){ answer = \"Even\"; } else{ answer = \"Odd\"; } return answer; }}","link":"/2020/01/26/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%A7%9D%EC%88%98%EC%99%80-%ED%99%80%EC%88%98/"},{"title":"[프로그래머스] 서울에서 김서방 찾기","text":"서울에서 김서방 찾기… 금방 풀었다라고 생각했고 테스트 통과까지 했다.하지만 정확성 테스트에서 털려버렸고 이유는 질문하기에서 금방 찾을 수 있었다. 그것은 바로 String 비교 문제에서 항등 연산자로 문제를 풀었던 것이다. 123456789101112131415//오답 코드 (정확성 테스트 실패)class Solution { public String solution(String[] seoul) { String answer = \"\"; int i = 0; for (i=0; i&lt;seoul.length; i++){ if (seoul[i] == \"Kim\"){ //문제의 그 부분 break; } answer = \"김서방은 \"+i+\"에 있다\"; } return answer; }} 자바에서 String을 비교할 때, .equals() 는 객체끼리 내용(값)을 비교할 수 있는 메소드이고(값 자체를 비교), == 는 객체의 참조(주소)값을 비교하는 연산자이다. 무심코 생각못하고 실전에서 이런 실수를 해버렸다면 정말 끔찍했을 것이다. 1234567891011121314//솔루션class Solution { public String solution(String[] seoul) { String answer = \"\"; String kim = \"Kim\"; int i = 0; for (i=0; i&lt;seoul.length; i++){ if (seoul[i].equals(kim)){ answer = \"김서방은 \"+i+\"에 있다\"; //띄어쓰기 주의 } } return answer; }}","link":"/2020/01/26/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%84%9C%EC%9A%B8%EC%97%90%EC%84%9C-%EA%B9%80%EC%84%9C%EB%B0%A9-%EC%B0%BE%EA%B8%B0/"},{"title":"[프로그래머스] 순열 검사","text":"배열의 크기가 4면 1부터 4까지 무조건 중복없이 숫자가 들어간다. arr = [4,2,3,1] 하지만 원소의 순서는 뒤죽박죽이 되어 있을 수 있다. 그러므로 java.util.Arrays를 import 하고 매개변수로 들어오는 arr 배열을 sort 시켜준다. 그리고 arr의 index와 index 내부의 원소가 같은 지 판별하는 알고리즘을 짜도록 한다. 12345678910111213141516import java.util.Arrays;class Solution { public boolean solution(int[] arr) { boolean answer = true; Arrays.sort(arr); for (int i=0; i&lt;arr.length; i++){ //배열의 첫번째 방(0번째 방)에 원소 1이 있는지부터 판별 if(arr[i]!=i+1) { answer = false; break; } } return answer; }}","link":"/2020/01/22/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%88%9C%EC%97%B4-%EA%B2%80%EC%82%AC/"}],"tags":[{"name":"프로그래머스","slug":"프로그래머스","link":"/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"알고리즘","slug":"알고리즘","link":"/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"정렬","slug":"정렬","link":"/tags/%EC%A0%95%EB%A0%AC/"},{"name":"sort","slug":"sort","link":"/tags/sort/"},{"name":"copyOfRange()","slug":"copyOfRange","link":"/tags/copyOfRange/"},{"name":"parse","slug":"parse","link":"/tags/parse/"},{"name":"ascii","slug":"ascii","link":"/tags/ascii/"},{"name":"atoi","slug":"atoi","link":"/tags/atoi/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Blog","slug":"Blog","link":"/tags/Blog/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"plugin","slug":"plugin","link":"/tags/plugin/"},{"name":"equals()","slug":"equals","link":"/tags/equals/"},{"name":"==","slug":"","link":"/tags/"}],"categories":[{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Programmers","slug":"Algorithm/Programmers","link":"/categories/Algorithm/Programmers/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"}]}