{"pages":[{"title":"about","text":"Footprints Education : 상명대학교 컴퓨터과학과 (7학기 재학 중 / 2021년 8월 졸업 예정) Github URL: https://github.com/msj0319 Career : 멋쟁이 사자처럼 (대외 동아리) 2020.01 ~ 2020.12 8기 운영진 활동, 8기 신입부원 과제수행 및 멘토링 진행 2019.01 ~ 2019.12 7기 신입부원 활동, Android/Kotlin Study, Hackathon 참여출처: 멋쟁이 사자처럼 공식 유튜브 채널 디지털 융복합 코로나19 관련 지역사회 문제해결 분야 창업 공모전 3위 (2020.09.28) 과학교육키트 관련 사업 엑시트 사이언스 창업 (2020.09.29 ~ ) ‘R’시큐어 주식회사 품질기획팀 인턴 2019.07.17 부터 2020.01.16 까지 (총 6개월) QA 업무 보조 및 제품 테스트 업무 진행 테스트 케이스 고도화 PC 제품, 모바일(Android, iOS) 제품 테스트 모바일 OS, 버전별 Android OS 루팅, iOS 탈옥 테스트를 통한 제품 취약점 발견 루팅 수행 과정 방법을 상세 기술한 문서 작성, 업데이트 전사 개발 팀 및 품질기획팀 내 문서 공유 경험 JIRA 소프트웨어를 사용한 이슈 등록 및 관리 경험 제품 별 증적자료 문서화 경험 Projects : 핸드폰 초기 불량 테스트 애플리케이션 https://github.com/msj0319/OneQTesterApp-Project (원큐테스터) 타인과 이야기를 공유하는 고민 상담 애플리케이션 (PlaNetwork) https://github.com/msj0319/Planetwork 소프트웨어공학 팀 프로젝트 (할뚜이따) https://github.com/msj0319/Halttuetta 상명대학교 학생들을 위한 정보 공유 랜덤 채팅 서비스 (MISO/ 미소) https://github.com/msj0319/miso_capstone_design_project출처 : 한국대학신문(http://news.unn.net/news/articleView.html?idxno=236324) Etc : 기술 블로그 운영 https://msj0319.github.io/","link":"/about/index.html"}],"posts":[{"title":"[Git] Branch 관련 명령어","text":"브랜치 생성 1git checkout -b &lt;브랜치 이름&gt; 다른 브랜치로 전환 1git checkout &lt;브랜치 이름&gt; 원본 브랜치 (master 브랜치)로 전환 1git checkout master 브랜치에 push 하기 123git add .git commit -m &quot;커밋 내용&quot;git push origin &lt;브랜치 이름&gt; 특정 브랜치 소스코드 Clone 받기 1git clone -b &lt;브랜치 이름&gt; --single-branch &lt;리포지토리 주소&gt; 원격(remote) 브랜치 삭제하기 1git push origin --delete &lt;브랜치 이름&gt; 내 로컬 저장소(내 컴퓨터)에서 개발 중인 로컬 브랜치 삭제하기 1git branch -d &quot;브랜치 이름&quot;","link":"/2020/07/30/Git-01-Git-%EB%AA%85%EB%A0%B9%EC%96%B4-%EB%A9%94%EB%AA%A8/"},{"title":"[HTML&#x2F;CSS] 01. HTML&#x2F;CSS 기초","text":"본 내용은 필자가 부스트코스 웹UI 개발 코스를 수강 후 공부하기 위해 정리한 것임을 알려드립니다. HTML의 이해HTML 소개- Hypertext Markup Language 의 약자. 웹페이지를 만드는 언어 Hypertext란, 텍스트를 초월하는, 텍스트 그 이상이라는 말. : Link Markup Language : 정보를 구조적으로 표현 가능한 언어. : HTML 파일확장자는 .html 영국의 물리학자 팀 버너스 리가 최초로 제안하여 개발됨. HTML 문법태그 HTML은 태그의 집합 통상적인 태그의 의미는 무언가를 표시하기 위한 꼬리표, 이름표라는 의미 기본적으로 &lt;, &gt; 기호로 표현하며, 괄호안에 태그 이름이 들어간다. 시작 태그와 종료 태그로 이루어져있고 종료 태그는 &lt;/&gt; 기호가 붙는다. 시작 태그와 종료 태그 사이에 실제 화면에 나타나는 내용이 위치된다. 12&lt;h1&gt; Hello, World &lt;/h1&gt;&lt;!--h1 태그를 사용하여 Hello, World를 출력한다.--&gt; 내용을 포함한 전부를 ‘요소’라고 한다. 각 태그에는 의미가 있고, 각 의미에 맞게 사용해야 한다. XML, SGML, XHTML에도 태그를 사용한다. 속성 Attribute HTML 태그들은 모두 속성을 갖고 있음 속성은 태그에 추가적으로 정보를 재공하거나, 태그의 동작이나 표현을 제어할 수 있는 설정값을 의미한다. 이름과 값으로 이루어짐 123&lt;h1 id=&quot;title&quot;&gt;Hello, World&lt;/h1&gt;&lt;!--시작 태그에서 태그 이름 뒤에 공백으로 구분--&gt;&lt;!--속성이름=&quot;속성 값&quot;으로 표현--&gt; Equal 사인 뒤에는 절대 공백이 와선 안된다. 하나의 태그에 여러 속성을 선언할 수 있다. 12&lt;h1 id=&quot;title&quot; class=&quot;test&quot;&gt;Hello, World&lt;/h1&gt;&lt;!--속성들의 순서는 중요하지 않다.--&gt; 속성은 종류에 따라 모든 태그에 사용가능한 글로벌 속성, 특정 태그에만 사용가능한 속성으로 구분된다. 선택적으로 쓸 수 있는 속성, 특정 태그에서 필요한 필수 속성으로 구분된다. 태그의 중첩 태그는 중첩이 가능함. 내부에 선언되는 태그는 반드시 부모 태그를 벗어나면 안됨. 온전히 부모 태그 안에서 시작되고 끝나야 한다. 태그 안에 중첩이 얼마나 되는지, 어떤 태그가 중첩이 되던 상관없다. 경우에 따라선 정해진 태그들만 중첩이 가능한 경우도 있다.12345678910111213&lt;h1&gt;Hello, &lt;i&gt;World&lt;/i&gt;&lt;/h1&gt;``` #### **빈 태그**- 시작 태그만 존재하고 종료 태그가 존재하지 않는 태그 - 종료 태그가 존재하지 않기 때문에 내용이 들어갈 수 없다.- 입력하는 내용만 비어있고, 속성을 통해 화면을 나타내거나 화면에 표시되지 않더라도 다른 용도로 사용되는 태그- 브라우저가 작성자 대신 내용을 그려야 하는 경우에 사용한다. - 이미지, 비디오 등 외부 리소스 삽입 시.- 브라우저가 내용을 대체한다라는 뜻으로 `Replacement Tag`라고 불린다.```html&lt;br&gt;&lt;img src = &quot;&quot;&gt; &lt;!--이미지 삽입 태그, 브라우저에 이미지 경로 전달(src 속성)--&gt; 공백주석","link":"/2021/01/04/HTML-CSS-01-HTML%EC%9D%98-%EA%B8%B0%EB%B3%B8/"},{"title":"[BOJ] 10828번 - 스택","text":"학부생 때 배웠던 스택 자료구조 이론을 토대로 스택 배열 생성, push , pop 연산 등을 구현해보는 문제였다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Scanner;public class Main { public static void main(String[] args){ Scanner sc = new Scanner(System.in); int num = sc.nextInt(); int top = -1; int[] stack = new int[num]; for (int i=0; i&lt;num; i++){ String input = sc.next(); if (input.equals(\"push\")){ stack[++top] = sc.nextInt(); } else if (input.equals(\"pop\")) { if (top == -1) { System.out.println(-1); } else { System.out.println(stack[top]); top--; } } else if (input.equals(\"size\")) { System.out.println(top+1); } else if (input.equals(\"empty\")) { if (top == -1){ System.out.println(1); } else { System.out.println(0); } } else if (input.equals(\"top\")){ if (top == -1) { System.out.println(-1); } else { System.out.println(stack[top]); } } } }}","link":"/2020/02/12/BOJ-10828%EB%B2%88-%EC%8A%A4%ED%83%9D/"},{"title":"[Hexo Blog] Markdown 플러그인 설치","text":"마크다운은 간단한 인라인 코드를 작성할 때 백틱을 이용한다. 1`(넣을 내용)` 근데 잘 쓰고 있던 중 어떤 md 파일은 먹히는데 새로 작성하는 파일에선 되지 않는 현상을 발견했다. 구글링을 통해 삽질을 해본 결과 기본 hexo는 원래 해당 태그를 지원하지 않는다는 사실을 어느 블로그를 통해 알게 되었고 당장 hexo 용 마크다운 플러그인을 설치했다. 참조 : https://d2fault.github.io/2018/07/03/20180703-smart-posting/ Installhttps://github.com/CHENXCHEN/hexo-renderer-markdown-it-plushexo가 설치 된 루트 폴더 (블로그 theme 상단 경로)에 아래 npm 명령을 입력한다. 12npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it-plus --save _config.yml 설정1234567891011#Markdown 플러그인 설치markdown_it_plus: highlight: true html: true xhtmlOut: true breaks: true langPrefix: linkify: true typographer: quotes: “”‘’ pre_class: highlight _config.yml 파일 최하단에 다음 구문을 넣어 설정한다.","link":"/2020/01/28/Hexo-Blog-Markdown-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-%EC%84%A4%EC%B9%98/"},{"title":"[안드로이드][Kotlin] View 형식에 따른 Intent 데이터 주고받기","text":"졸업 프로젝트를 위해 프로토타입을 만들던 중 될 것 같던 부분이 안되어 해결 후 정리해보았다. 하나의 액티비티에서 데이터를 다른 액티비티로 보내기 위해선 intent 객체를 만들어 putExtra() 메소드로 데이터를 묶어 보낸다. 그리고 받는 액티비티에선 getXXExtra() (XX는 자료형) 메소드로 데이터를 받는 것이 기본적이다. 간단한 회원가입 레이아웃을 만들고, 사용자가 Plain Text View에 학번(StudentID)을 입력한다. 제출 버튼을 누르면 해당 액티비티 VerifyEmailActivity 에 보내고, 동일한 Plain Text 에 입력했던 아이디가 그대로 나타나는 로직을 구현하고 싶었다. 사용자가 한번 더 입력할 필요없이 한번 입력했던 학번이 자동으로 표시되도록 만들고 싶었다. 1234// 데이터 보내는 액티비티val intent = Intent (this, VerifyEmailActivity::class.java)intent.putExtra(&quot;studentID&quot;,studentID.text.toString())startActivity(intent) 123// 데이터 받는 액티비티var studentID = intent.getStringExtra(&quot;studentID&quot;)TextView.text = studentID //오류가 난 부분 TextView는 사용자의 직접 입력없이 설정한 text만 설정하면 보여지는 View이기에 이렇게 간단하게 원하는 Text를 인텐트로 받아 설정할 수 있었다. 하지만 사용자가 입력한 Text가 인텐트로 보냈을 시 받는 View의 상태가 만약 똑같은 Plain Text라면 다음 코드 처럼 작성해야 한다는 것을 알게 되었다. 12345678//코드 수정 Plain Text -&gt; Plain Textvar studentID = intent.getStringExtra(&quot;studentID&quot;)if (!studentID.isNullOrEmpty()) { studentIDText.setText(studentID) //setText method 사용 } else { ... }","link":"/2020/03/11/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-View-%ED%98%95%EC%8B%9D%EC%97%90-%EB%94%B0%EB%A5%B8-Intent-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A3%BC%EA%B3%A0%EB%B0%9B%EA%B8%B0/"},{"title":"[Hexo Blog] 구글 사이트 등록 및 검색엔진 최적화(SEO)","text":"Hexo 블로그를 만들었다면 구글에 키워드 서칭 시 내 블로그가 검색이 잘 되도록 하는 과정을 알아보자. 검색 최적화구글 같은 검색 엔진을 주로 서비스하는 사이트들은 크롤링 이라고 하는 작업을 통해 여러 웹사이트나 블로그 들의 정보를 검색 엔진에 수집해서 사람들이 검색을 할 시 해당 사이트들을 사용자들에게 노출시킨다고 한다. 일단 기술 블로그만 만들면 장땡일 줄 알았는데 막상 이런 작업을 하려고 하니 막막하지만 블로그를 좀 더 개선할 수 있는 방법이기 때문에 바로 시작한다.구글에 Hexo만 검색해도 검색엔진 최적화 라는 방법들을 여러 사람들이 쓰는 것을 알 수 있었는데, 줄여서 SEO 라고 한다. 즉 Search Engine Optimization 은 검색엔진에 맞게 사이트를 제작, 운영하는 과정 전부를 말한다.SEO 과정을 시작하기 위해서는 Hexo 프로젝트에 몇가지 플러그인 설치가 필요하다. 플러그인 설치hexo-auto-canonical메타 태그 중 canonical 속성을 대표 URL이라 뜻하고 각 포스트마다 자동으로 표준 링크를 만들어 준다. 설치 npm-install --save hexo-auto-canonical 설정설정은 내 블로그 테마 기준, theme 폴더 아래의 layout/common/head.ejs 파일에서 제일 하단에 구문을 추가한다. 12&lt;!--Canonical : 유사하거나 중복된 페이지의 표준 페이지 정의--&gt;&lt;%- autoCanonical(config, page) %&gt; head.ejs 구문을 만지작하고 deploy 하니 head 태그 아래에 &lt;link rel=&quot;canonical&quot; href=&quot;https://msj0319.github.io/&quot;&gt; 라고 설정이 된 것을 확인할 수 있다. 메타 태그 (meta tag)는 해당 웹 페이지의 정보를 담은 태그로 &lt;head&gt; 태그 안에 있다고 한다. 이 메타 태그가 잘 들어가 있어야 검색엔진이 이 사이트를 잘 인식해서 수집이 잘된다고 한다. 참조 : https://futurecreator.github.io/2016/06/15/hexo-google-site-search-console-analytics/ 웹 개발 쪽은 잘 몰랐는데 여러 ejs 파일들이 이런 식으로 각자 할일들이 있는 모양새인듯 하다. 시간나면 공부해 봐야겠다. hexo-autofollow해당 포스트에서 참고하고 있는 외부링크에 대해 nofollow 속성을 자동으로 추가하는 플러그인이다. 앞서 언급했듯이 검색엔진은 사람들이 서칭활동을 하는데에 있어 원하는 웹페이지를 되도록 많이 수집하는데 이런 크롤링 작업을 하는 로봇을 크롤러 또는 구글봇이라고 한다. 이런 로봇에게 어떤 페이지는 수집하지 말라고 얘기할 필요가 있기 때문에 이런 기능이 필요한 것이다. 설치 npm install hexo-autonofollow --save 설정 (theme/_config.yml)12345nofollow: enable: true exclude: - exclude_1.com #예외처리 할 사이트 등록 - exclude_2.com hexo-generator-seo-friendly-sitemapSitemap 생성기, 사이트맵을 등록하면 크롤링 작업을 하는 봇들이 좀 더 효율적으로 크롤링 작업을 할 수 있게 도와주는 역할을 한다. 설치 npm-install hexo-generator-seo-friendly-sitemap --save 설정 (theme/_config.yml)123456# 검색 엔진에서 크롤링 할 페이지들을 결정해주는 xml 파일 생성sitemap: path: sitemap.xml #블로그 주소/sitemap.xml #여기까지만 쓴다. 아래는 옵션 tag: true #Defualt: true category: true #Default: true tag 속성 : sitemap에 tag 정보 포함 여부category 속성 : sitemap에 마찬가지로 카테고리 포함 여부 (실제로 root 폴더 내부에 sitemap.xml 파일들이 생성된 것이 보인다.) hexo-generator-feed자동으로 Atom 1.0 또는 RSS2.0 피드 생성해주는 플러그인이다. 설치 npm install hexo-generator-feed --save 설정 (theme/_config.yml)123456789feed: type: rss2 #atom / rss2 path: rss2.xml #(Defult: atom.xml/rss2.xml) - 네이버에선 atom 미지원으로 인해 rss2로 설정 limit: 20 #공개할 rss feed 수 # 기본적으로 여기 까지만 쓴다. 아래는 옵션 hub: content: content_limit: 140 #요약 글자 수 content_limit_delim: '' root/_config.yml12# Path or URL to RSS atom.xmlrss: /rss2.xml #feed에서 등록한 rss 주소 입력 hexo-generator-robotstxt설치 npm install hexo-generator-robotstxt --save 설정1234robotstxt: User-agent: \"*\" Allow: / Sitemap: https://msj0319.github.io/sitemap.xml Sitemap 속성엔 미리 Sitemap 플러그인 설치 후 설정한 사이트맵의 주소를 넣는다. 그 뜻은 robots 생성 플러그인 설치를 위해선 사이트맵 플러그인 설치가 선행되어야 한다.설정이 모두 끝난 후 Deploy를 하면 모든 검색엔진 최적화를 위한 플러그인 설치는 끝난다.","link":"/2020/02/14/Hexo-Blog-%EA%B5%AC%EA%B8%80-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EB%93%B1%EB%A1%9D-%EB%B0%8F-%EA%B2%80%EC%83%89%EC%97%94%EC%A7%84-%EC%B5%9C%EC%A0%81%ED%99%94-SEO/"},{"title":"[안드로이드] 앱 상단바 없애기","text":"프로젝트의 values 디렉토리 내부의 styles.xml에 아래 구문을 추가한다. 1234567891011121314&lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.DarkActionBar\"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt; &lt;!-- 상단바 없애기 --&gt; &lt;item name=\"windowActionBar\"&gt;false&lt;/item&gt; &lt;item name=\"windowNoTitle\"&gt;true&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt;","link":"/2020/03/06/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%95%B1-%EC%83%81%EB%8B%A8%EB%B0%94-%EC%97%86%EC%95%A0%EA%B8%B0/"},{"title":"[안드로이드] 앱 프로젝트에서 SHA-1, SHA-256 인증서 지문 찾기","text":"작업 Window에서 오른쪽에 보면 Gradle로 작은 탭이 있는 것을 볼 수 있다.그걸 누르고 app-&gt;Tasks-&gt;signingReport 를 더블 클릭하면 아래 콘솔 창에 원하는 정보가 출력된다.","link":"/2020/03/08/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%95%B1-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90%EC%84%9C-SHA-1-SHA-256-%EC%9D%B8%EC%A6%9D%EC%84%9C-%EC%A7%80%EB%AC%B8-%EC%B0%BE%EA%B8%B0/"},{"title":"[Hexo Blog] 블로그 방문자 및 조회수 카운팅 기능 넣기 (Busuanzi)","text":"해당 포스트는 Hexo theme 중 icarus 테마에 적용한 내용입니다. 지원이 되지 않거나, 설정 방법에서 약간의 차이가 있을 수 있습니다. 간단하게 블로그 하단에 방문하신 분들이 몇 명이나 되었는지, 또한 글을 얼마나 봐주셨는지에 대해 간단히 표시할 수 있는 기능을 설정하는 법을 알아보자. Busuanzihexo 프레임워크가 애초에 중국에서 만들어졌다보니 웹페이지에 필요한 라이브러리 중 방문자, 조회수 카운팅 기능도 중국 라이브러리라는 것을 알게되었다. Busuanzi 공식 사이트 : https://busuanzi.ibruce.info/ Busuanzi 사용 법 기술 사이트 : http://ibruce.info/2015/04/04/busuanzi/ 설정먼저 theme\\_config.yml 로 들어가 busuanzi 섹션을 찾고 해당 기능을 true로 상태를 활성화 시킨다.그 다음 theme\\layout\\common\\footer.ejs 에서 몇가지 구문을 넣어준다. 123456789&lt;% if (busuanzi) { %&gt; &lt;!--만약 busuanzi 가 활성화됐으면--&gt; &lt;br&gt; &lt;span id=\"busuanzi_container_site_pv\"&gt; 총 조회 &lt;span id=\"busuanzi_container_site_pv\"&gt;&lt;/span&gt; 회 &lt;/span&gt; | &lt;span id=\"busuanzi_container_site_uv\"&gt; 총 방문자 &lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt; 명 &lt;/span&gt; &lt;% } %&gt; 아직 많은…분들께서 방문해주시지 못했지만 이렇게 기능이 추가된 것을 볼 수 있다.열심히 노력하자!","link":"/2020/02/15/Hexo-Blog-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%B0%A9%EB%AC%B8%EC%9E%90-%EB%B0%8F-%EC%A1%B0%ED%9A%8C%EC%88%98-%EC%B9%B4%EC%9A%B4%ED%8C%85-%EA%B8%B0%EB%8A%A5-%EB%84%A3%EA%B8%B0/"},{"title":"[안드로이드] 앱 인터넷 권한 설정","text":"Android.xml의 &lt;manifest&gt; 태그 내부에 해당 구문 추가. 12&lt;!--인터넷 권한 설정--&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;&gt;&lt;/uses-permission&gt;","link":"/2020/03/08/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%95%B1-%EC%9D%B8%ED%84%B0%EB%84%B7-%EA%B6%8C%ED%95%9C-%EC%84%A4%EC%A0%95/"},{"title":"[자료구조] 02. 성능분석","text":"본 내용은 필자가 학부 자료구조 수업내용을 공부하기 위해 정리한 것임을 알려드립니다. 2-1. 성능이란 무엇인가?어떤 자료구조가 좋은 자료구조인지 쉽게 생각해보려면 내가 여러 지도 앱에서 원하는 경로를 검색할 때를 생각해보면 편하다. 만약 카카오 맵 앱에서 서울역부터 집까지 가는 경로를 검색할 때는 0.1초가 걸리고 네이버 지도 앱에서 동일한 경로를 검색할 때는 0.2초가 걸린다고 가정하자. (물론 예시일 뿐 네이버 앱이 안좋은 서비스라는 것은 아니다.) 동일한 입력(출발지: 서울역, 도착지: 우리 집)을 주었을 때 빠른 시간 내에 정답(가장 빠른 경로)을 출력하는 앱이 가장 좋은 앱이 되고, 카카오 맵 앱은 좋은 자료구조로 짜여있다고 말할 수 있다. 결과적으로 성능이 좋다 (재차 강조하지만 네이버 지도 앱을 비하하려는 목적이 아니다.) 그럼 성능이란 무엇일까? 성능(Performance) 또는 효율(Efficient)이라고 말할 수 있다. 동일한 성과(Soluton)를 도출하기 위해서 요구되는 자원(Resource)의 크기 Performance = solution / resource 효과적(effective)이란 투입하는 자원(Resource)이 같을 때 얼마나 많은 solution을 도출하는가? 성능의 세가지 측면 최선의 경우 (Best Case) 평균의 경우 (Average Case) 최악의 경우 (Worst Case) 시스템에 과도한 입력(사용자의 요청)이 들어와도 적어도 ‘해당 시간’에 처리한다. '보장'의 의미 성능은 솔루션/자원이다. 그 중 분모에 해당하는 자원(리소스)은 컴퓨터의 자원을 뜻하는데, 컴퓨터의 자원이라 함은 메모리와 CPU가 있다. 무어의 법칙의 한계가 올 정도로 기술은 급속도로 변화되면서 공정 세밀화와 실리콘 기반 반도체에 한계가 찾아왔다. 20nm 이후로는 기술적 구현 측면보다는 경제성의 측면에서 무어의 법칙이 멈출거라고 보는 전문가들이 많기 때문에 CPU의 성능은 좋아져도 가격이 어마무시하게 뛰게 될것이다. 반대로 메모리는 용량은 기하급수적으로 커지고 가격은 점점 싸지고 있다. 공간 복잡도 (Space-Complexity)“특정한 프로그램을 수행하는 데 요구되는 메모리” 공학적으로 생각해볼 때 메모리의 Cost는 낮아지고 용량은 커지고 있으므로 공간복잡도는 성능을 측정할 때 고려할 요소가 되지 않는다. 시간 복잡도 (Time-Complexity)“특정한 프로그램을 수행하는 데 요구되는 시간” 시간복잡도로 시스템의 성능을 측정한다. 2-2. 점근적 분석법 (Asymptotic Complexity) 성능은 입력의 크기에 따라에 결정됨 실제로 프로그램의 성능을 공정하게 판단하기 위해서는 입력의 크기만으로 판단한다. n : 입력의 크기 시간 복잡도를 n(입력)의 함수로 표현 : f(n) 시간 복잡도는 매우 큰 입력에 대해서 측정한다. 동일한 크기의 입력 처리 시 같은 성능 함수 g(n)을 통한 f(n)의 성능 표현 g(n) &gt;= f(n) g(n) 함수가 f(n) 함수보다 증가율이 크다면 g(n)은 f(n)보다 성능이 나쁘다. g(n)은 f(n)보다 시간이 더 많이 걸린다. 최악의 경우에도 f(n)은 g(n)보다 좋다. f(n)의 upper bound(상한)는 g(n)이다. f(n)의 최악의 경우는 g(n)이다.","link":"/2020/05/08/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-02-%EC%84%B1%EB%8A%A5%EB%B6%84%EC%84%9D/"},{"title":"[자료구조] 03. Big-O 표기법","text":"본 내용은 필자가 학부 자료구조 수업내용을 공부하기 위해 정리한 것임을 알려드립니다. 2-3. Big-O 표기법 f(n) = O(g(n)) 입력의 크기가 무한히 커질 때, 입력이 특정한 입력(n0)보다 크기만 하면 f(n)은 항상 M * g(n) 보다 작거나 같다를 만족하는 특정한 입력(n0)과 M이 존재한다. f(n) &lt;= g(n) f(n) &lt;= g(n) for n0 &lt; n f(n) &lt;= M*g(n) for n0 &lt; n 동일한 비율로 증가하는 함수를 허용하기 위해 상수 M을 허용한다. 성질 1어떤 n &gt; n1 에 대해서 g1(n) &lt; g2(n) 이라면 f(n) = O(g1(n))은 f(n) = O(g2(n))을 의미한다. f(n) = O(g(n))이고, g1(n)보다 g2(n) 함수가 더 성능이 좋지 않을 때, f(n)의 입장에서도 g2(n)은 upper bound다. 성질 2어떤 상수 k에 대해서 f(n) = O(k*g(n))이라면, f(n) = O(g(n))이다. k는 생략 가능하다. 성질 3f(n) = O(g1(n) + g2(n))이고, 어떤 n &gt; n1에 대해서 g1(n) &lt; g2(n)이라면 f(n) = O(g2(n))이다. 두 함수 중 낮은 계수는 생략되고, 높은 계수(성능이 좋지않은)가 곧 빅 오 표기법 함수로 대표된다. 빅 오메가(Big-Omega) 표기법 빅 오 표기법과 반대되는 의미 f(n) = O(g(n)) 일 때, g(n) = Ω(f(n)) g(n)은 f(n)보다 느리다. g(n)의 lower bound는 f(n)이다. 빅 세타(Big-Theta) 표기법 동일한 n에 따라 f(n)과 g(n)이 서로 근사치의 비율로 증가할 때 f(n) = O(g(n)) 과 g(n) = O(f(n)) 일 때. f(n) = Θ(g(n)) 2-4. Big-O 표기법의 예 상수 시간 복잡도 (constant time complex) f(n) = O(1) 반복문을 이용한 별 찍기 보다 printf(&quot;*&quot;)를 이용한 별 찍기가 효율이 좋다!(?) 입력이 증가해도 일정한 시간이 걸린다. 가장 이상적인 성능 123void f(int n) { printf(\"Hello\");} 선형 시간 복잡도(linear time complex) f(n) = O(n) 시간은 입력의 크기(n)에 비례한다. for-loop와 while문 1234567void f(int n) { i=0; while (i &lt; n) { printf(\"hello\"); i++; }} 다항 시간 복잡도(Polynomial time complex) f(n) = O(n^k) if k=2 f(n) = O(n^2) 시간은 입력의 크기의 k제곱에 비례해서 증가한다. k=2 일때 삽입, 버블, 선택 정렬 시간복잡도 1234567void f(int n) { for (i=0; i&lt;n; i++){ //외부 loop O(n) for (j=0; j&lt;n; j++) { //내부 loop O(n) printf(\"hello\"); } }} //총 O(n^2)번 수행 지수 시간 복잡도(exponenetial time complex) f(n) = O(k^n) k=2 f(n) = O(2^n) 시간은 k의 n제곱에 비례해서 증가한다. 매우 매우 매우 좋지 않은 시간복잡도 k=2 일때 피보나치 수열, 높이가 n인 tree에서 전체 노드의 갯수 123456789/// 토끼의 수 : f(n) = f(n-1) + f(n-2)int f(int n){ if (n == 0) return 0; if (n == 1) return 1; return f(n-1) + f(n-2);} 피보나치 수열은 자기 자신을 이용해 개념을 정의한다. 따라서 Recursive(재귀적으로)로 구현한다. 입력받은 n이 0이거나 1이 아닌 경우 f(n-1) + f(n-2) 계산값을 return 한다. 입력 값이 높아질 수록 피보나치 수열을 계산하기 위해 불필요한 계산이 많아진다. n=6일 뿐인데 함수 호출 수는 25번이다. f(n)이 불리는 횟수 = 2^n 번 로그 시간 복잡도(log time complex) f(n) = O(log n) 시간은 n의 log에 비례해서 증가한다. 밑(k : base)는 생략 로그의 base에 따라 성능에 영향을 주긴 하지만 그 차이는 알고리즘 성능에서 매우 미미한 차이기 때문에 생략이 가능하다. 12345int f(int n) { for (k=1; k&lt;n; k = k*10) { printf(\"hello\"); }} k가 1,2,3…씩 증가할 때마다 코드는 1번, 10번 100번, 10000번…수행된다. 만약 입력 값이 1경정도라면 해당 코드에서 15번 loop시 수행이 끝나는 최강의 성능을 보여준다. nlogn 시간 복잡도(nlogn time complex) f(n) = O(nlogn) O(n) 보단 느리고 O(n^2)보단 빠른 성능 1234567void f(int n) { for (i=1; i&lt;n; i++) { // outer loop O(n) for (j=1; j&lt;=n; j*=10) { // inner loop O(logn) printf(\"hello\"); } }} 결론","link":"/2020/05/08/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-03-Big-O-%ED%91%9C%EA%B8%B0%EB%B2%95/"},{"title":"[자료구조] 01. 자료구조란 무엇인가?","text":"본 내용은 필자가 학부 자료구조 수업내용을 공부하기 위해 정리한 것임을 알려드립니다. 1-1. 컴퓨터란 무엇인가?컴퓨터는 ENIAC - 에니악 (전자식 숫자 적분 및 계산기)를 최초로 (ABC가 최초의 컴퓨터라는 이의로 미국 법원에서 승소, 영국이 발명한 콜로서스가 최초라는 말도 존재한다.) 30년 뒤 Apple 2 컴퓨터, 그 후로 30년 뒤 iPhone 이 발명되었으며 지금에 이르기 까지 존재했다. 그럼 다음 세대가 될 컴퓨터는 무엇일까? 우리는 3 * 4 = 12 이고 13 * 3 = 39 라는 계산 식을 암산으로 쉽게 계산이 가능하다. 하지만 세자리 수 * 세자리 수 계산은 종이에 써보면서 계산하거나 계산기를 이용하여 답을 도출해내는 것이 일반적이다. (암산으로 가능한 사람이 있을 수 있고…) 연산과 기억을 동시에 해야한다 라는 점 때문에 우리는 복잡해지는 연산을 쉽게 계산하기 어려운 것이다. Computer?계산하는 사람이라는 뜻의 단어로 요즘은 Desktop, 스마트폰 등 여러가지 전자기기에 붙는 수식어가 되었다. 앞서 말했 듯 계산은 연산과 기억을 동시에 수행해야 한다고 말했다. 계산(Computation) = 연산(calculation) + 기억 (Memory) 컴퓨터 = CPU + Memory 튜링 머신을 시작으로 좀 더 보완된 폰 노이만 구조가 요즘 컴퓨터에 까지 쓰이고 있다. 연산을 저장하는 Memory 연산을 담당하는 Processor 컴퓨터의 내부를 담당하는 Control Unit 수치, 논리계산을 담당하는 ALU 부분으로 구성되어 있다. 메모리와 프로세서가 서로 상호작용하며 연산을 수행한다. 1-2. 자료구조란 무엇인가?자료구조란 데이터를 효율적으로 관리하는 기법이다. 데이터 (Data) : 데이터를 저장하는 기본적인 단위 (int, float, char, class/struct, etc) 효율적 (Efficiency) : solution/resource solution을 내기 위해 투입 된 resource 로 나눈 것. 공간(Memory) 적게, 시간(CPU)도 적게. 관리 : 프로그램을 사용하며 많이 사용하는 연산 삽입, 검색, 제거 기법 : 구조 (데이터가 저장되어 있는 구조) + 연산 (삽입, 검색, 제거) 추상 자료형 (Abstarct data type)","link":"/2020/05/07/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-01-Introduction/"},{"title":"[자료구조] 05. Array","text":"본 내용은 필자가 학부 자료구조 수업내용을 공부하기 위해 정리한 것임을 알려드립니다. 5.1. 배열 (Array) 배열의 성질 list를 index를 이용하여 구현 연속적으로 할당 된 공간 프로그램 언어에서 기본적으로 제공 배열의 모든 원소는 index에 대응 n개의 자료를 하나의 주소로 접근 가능 배열의 첫번째 요소의 메모리 주소를 기본 주소라고 한다. arr[0] 메모리 주소에 접근하면 배열의 끝까지 접근 가능하다. 메모리에서 배열의 구현int mylist[5];를 C언어에서 선언했다고 가정하자. int mylist[5]; 선언 OS에 배열 요청 OS는 메모리에게 여유 공간이 있는 지 묻는다. Memory 승인 주소를 할당 mylist 배열은 시작주소로 23040번지를 할당했다고 가정해보자. 5개의 메모리를 선언했으므로 23040 ~ 23044번지 까지 연속된 메모리를 할당받는다. mylist 배열의 주소 == mylist[0]의 주소, n개의 자료를 하나의 주소로 접근 가능하다. 배열의 친구들 arr : 배열의 주소 size : 배열의 크기 (할당받은 메모리의 크기) count : 배열에 저장된 현재 원소의 갯수 count &lt;= size 반드시 0으로 초기화 하여 사용할 것 정적 배열 할당 12345#define SIZE 100 { int count = 0; int arr[SIZE];} 동적 배열 할당 12345#define SIZE 100{ int count = 0; int *arr = calloc(SIZE,sizeof(int)); } 배열의 연산 생성(Create) : int L[10]; 인출(Retrieve) : int x = L[5]; 저장(Store) : L[5] = x; 5.2. 배열의 검색 정렬된 배열 linear_search(A,x) binary_search(A,x) 정렬되지 않은 배열 linear_search(A,x) 검색(Search)내가 찾는 원소의 index를 return. 원소가 없으면 -1 또는 NULL return 선형 검색(Linear Search) 완전 검색, 순차 검색 첫번째 원소부터 차례로 방문 Unsorted Array 적용 가능 123456789index linear_search(Array arr, elt x){ for (int i=0; i&lt;n; i++) { if (arr[i] == x) return i; else return -1; }} 최악의 경우 : O(n) 평균의 경우 : O(n/2) 배열의 중간에서 key값을 찾은 경우 O(n) 최선의 경우 : O(1) : 바로 key값을 찾은 경우 이진 검색(Binary Search) 정렬 된 배열에서만 사용 가능 Divide &amp; Conquer(분할 정복) 알고리즘 배열 중간 원소와 key element 비교. 배열 분할 하며 검색. 배열의 중간 원소(mid)를 찾아 배열을 절반으로 Divide, 탐색을 재귀적으로 수행12345678910111213141516index binary_search(Array arr, index s, index e, elt x){ if (s==e) return (arr[s] == x) ? s : -1; //원소가 1개인 배열, start와 end가 같을 때 int mid = (s + e) / 2; if (x == arr[mid]) return mid; else if (arr[mid] &gt; x) //key는 mid보다 작기 때문에 return binary_search(arr, s, mid-1, x); //end를 mid-1로 설정 (Divide) else return binary_search(arr, mid+1, e, x); //key가 mid보다 크므로 mid+1을 start로 설정 (Divide)} recursive 구현 T(n) = T(n/2) + O(1) Recursive의 단점을 보완한 Iterative 이진 검색 구현1234567891011121314151617181920index binary_search(Array arr, elt x){ int s = 0; int e = count-1; int mid; while(s&lt;=e) { mid = (s + e) / 2; if (x == arr[mid]) //mid 값이 x값과 일치하면 리턴 return mid; else if (arr[mid] &gt; x) //mid 인덱스 값보다 x값이 작으면 e = mid - 1; // Divide else //mid 인덱스 값보다 x값이 크면 s = mid + 1; //Divide } return -1;} 최악의 경우 : O(logn) 최선의 경우 : O(1) - key값을 바로 탐색했을 때","link":"/2020/05/09/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-05-Array/"},{"title":"[자료구조] 04. List","text":"본 내용은 필자가 학부 자료구조 수업내용을 공부하기 위해 정리한 것임을 알려드립니다. 4.1. 1차원 자료구조우리는 다양한 앱을 사용한다 그런 다양한 앱을 통해 자료를 관리한다. 자세히 들여다보면 우리는 자료의 list를 관리한다. 자료의 관리는 ‘추가’, ‘검색’, ‘제거’로 이루어진다. 우리는 주소록 App에 새로 A라는 친구 번호를 ‘추가’하고, ‘제거’를 통해 B의 전화번호를 삭제한다. 하지만 사용빈도를 따져봤을 때 추가, 제거 보다는 ‘검색’ 연산을 통해 주소록에 저장 된 지인의 번호를 검색할 때가 가장 많다고 볼 수 있다. 따라서 검색이 잘 되는 자료구조가 가장 좋은 자료구조 라고 말할 수 있다. List의 정의 유한한 원소들의 나열 (a finite sequence of elements) 각 원소들은 index에 대응 된다. (index, element) 쌍 List 구현 방법 배열 (Array) : index에 기반한 구현 연결 리스트 (Linked List) : Pointer 에 기반한 구현 배열 연속된 기억공간 메모리에 배열의 크기보다 더 큰 공간이 허용되어야 한다. 연결리스트 원소 + 다음 원소의 주소 메모리에 배열의 크기보다 더 큰 연속된 공간이 없을 때 사용한다. Data + Link (다음 원소의 주소를 저장하는 Pointer) List 저장 방법검색 정렬된 list (Sorted List) (오름차순, 내림차순) 예측 가능한 원소의 위치 : 성능이 좋음 정렬되지 않은 list (Unsorted list) 원소의 위치를 예측할 수 없음 : 성능이 좋지 않음 추가 정렬된 list (Sorted List) 들어갈 원소의 자리가 정해져 있으므로, 삽입할 원소가 원소들 사이라면 기존 원소들을 뒤로 한 칸씩 밀어야 한다. 성능이 좋지 않음 정렬되지 않은 list (Unsorted list) 아무 자리에나 원소 삽입 : 성능이 좋음 삭제 정렬되었거나, 정렬되지 않은 list 모두 원소 사이의 원소를 제거하면 자리를 앞으로 땡기는 작업 수행 : 성능이 좋지 않음","link":"/2020/05/09/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-04-1%EC%B0%A8%EC%9B%90-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"title":"[프로그래머스] K번째 수","text":"배열 array를 i번째 부터 j번째 까지 자르고 정렬했을 때, k번째에 있는 수를 구한다. commands 배열의 각 행, 즉 i,j,k를 잘 뽑아내고 정렬 후 k번째 수를 answer 배열에 넣기만 하면 된다. i, j, k 명령 수행 시 k번째 수는 ‘하나’가 나오게 된다. commands의 길이는 1~50 이하 이므로 k번째 수를 담는 answer 배열의 크기는 commands.length 만큼 할당해야 한다. 그리고 i, j, k 값들을 각각 치환하여 사용하기 쉽게 만들었다. 또한 i번째 부터 j번-[ys.copyOfRange() 함수를 사용했다. 말 그대로 구간을 정해 copy하는 함수다. 첫번째 인자부터 배열의 주소(이름), 시작 인덱스, 종료 인덱스(종료 인덱스는 구간에 포함하지 않는다.) 이다. 12int[] array2 = Arrays.copyOfRange(array,i-1,j); // 배열은 0부터 시작하므로 i-1 한다. Arrays.sort() 해주고, k번째 (k-1번째 index) 수를 answer 배열에 넣고 return 해주면 된다. 123456789101112131415161718import java.util.Arrays;class Solution { public int[] solution(int[] array, int[][] commands) { int[] answer = new int[commands.length]; for (int index = 0; index&lt;commands.length; index++){ int i = commands[index][0]; int j = commands[index][1]; int k = commands[index][2]; int[] array2 = Arrays.copyOfRange(array,i-1,j); Arrays.sort(array2); answer[index] = array2[k-1]; } return answer; }}","link":"/2020/01/27/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-K%EB%B2%88%EC%A7%B8-%EC%88%98/"},{"title":"[프로그래머스] x만큼 간격이 있는 n개의 숫자","text":"문제 자체는 쉬웠지만 자칫 그냥 써버릴 수 있는 int 타입이 입력 변수 범위가 제한조건에 걸려 테스트케이스에서 실패를 했었던 문제다. 12345678910class Solution { public long[] solution(long x, int n) { long[] answer = new long[n]; for(int i=0; i&lt;n; i++){ answer[i] = x*(i+1); } return answer; }} 핵심 연산을 해주는 answer[i] = x*(i+1) 에서 반복문을 세주는 i가 int형이고 만약 x도 int형일 때 x*(i+1) 연산에서 answer[i] 값은 곱했을 때 당연히 int가 된다. (배열 선언은 long으로 해줬으면서 말이다.) 그래서 answer 배열은 n만큼 할당해줘야 하기에 solution의 변수 n을 int로 놔뒀고, 제한조건 범위 내의 연산을 위해(long 타입 연산을 위해) long 타입으로 바꿨다.","link":"/2020/02/07/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-x%EB%A7%8C%ED%81%BC-%EA%B0%84%EA%B2%A9%EC%9D%B4-%EC%9E%88%EB%8A%94-n%EA%B0%9C%EC%9D%98-%EC%88%AB%EC%9E%90/"},{"title":"[프로그래머스] 문자열을 정수로 바꾸기","text":"문자열의 길이는(s는) 1~5이고, s 맨 앞에는 부호(+,-)가 올 수 있다고 한다.부호에 따른 처리가 필요한 것인지 궁금했지만 일단 매개변수로 받은 문자열 s를 정수로 casting 해보았다. 123456789import java.util.*;class Solution { public int solution(String s) { int answer = 0; answer = Integer.parseInt(s); return answer; }} 우선 이렇게 코딩 후 실행하니 테스트케이스를 전부 통과했고, 놀랍게도 제출하니 정답으로 통과했다.하지만 남들이 푼 코드를 보니 API에 의존한 내가 너무 부끄럽게 느껴질 정도였다.남들이 푼 코드 중 하나를 가져와서 atoi에 대해 다시 한번 익혀보도록 하자. 12345678910111213141516171819public class Solution { public int solution(String str) { boolean plus = true; int value = 0; for (char ch : str.toCharArray()) { if (ch == '-') { plus = false; } else { int num = ch - 48; value = num+value*10; } } return (plus==true)? value : -1*value; }} 매개변수 문자열 str을 toCharArray로 문자로 char 변수에 받은 후 - 부호가 존재하면 plus 상태를 false라고 해주고 만약 +부호 일때는 if문을 벗어난다.문자 중 부호가 없으면 else 문으로 진입하게 되는데, 여기서부터가 atoi의 핵심이다. 12345678for (char ch : str.toCharArray()) { if (ch == '-') { plus = false; } else { int num = ch - 48; value = num+value*10; } String 객체에 담긴 문자열이 int 형 변수에 Integer로 Casting 되는 과정이다. 123456//ex) String = 12result = 0; //초기값result = (result * 10) + '1' - 48; //1result = (1 * 10) + '2' - 48; //12//result의 최종 결과 값은 12 초반에 result에 10을 곱해주는 이유는 Decimal 데이터를 얻어야 하기에 그렇다.또한 아스키코드 상에서 48은 문자열 0이므로 문자열 1(49)에서 문자열 0(48)을 빼주면 정수 1이 출력될 수 있다. 마지막으로 plus 상태가 true이면 바로 value 출력, false면 value에 -1을 곱한 후 리턴해주면 된다.","link":"/2020/02/06/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%AC%B8%EC%9E%90%EC%97%B4%EC%9D%84-%EC%A0%95%EC%88%98%EB%A1%9C-%EB%B0%94%EA%BE%B8%EA%B8%B0/"},{"title":"[프로그래머스] 문자열 다루기 기본","text":"문자열 다루기 기본 문제라는 문제 이름으로 쉬운 문제라고 생각하고 풀었다. 아스키코드 상으로 알파벳 소문자 또는 대문자가 문자열 안에 존재하면 answer 상태를 false로 바꿔주고 리턴까지 시켰다. 하지만 주어진 테스트 케이스를 통과하였지만 자꾸 테스트 5,6번에서 막혔고 이유가 뭔지 골똘히 생각하던 중에 그 이유를 찾을 수 있었다. 1문자열 s의 길이가 4 혹은 6이고, 숫자로만 구성되어 있는지 확인하는 함수, solution을 완성하세요. 아뿔싸. 문자열 s의 길이가 4또는 6인지 확인하는 구문을 넣지 않았다…해당 문제의 질문하기에는 쉬운 문제임에도 불구하고 많은 사람들이 “왜 테스트케이스 5,6번에서 막히는 거죠?” 라는 바보같은 질문을 올려댔다. 나도 그 이유를 몰라 찾아 해맸고 탄식이 나올 정도로 어이없었다. 다음부턴 입출력만 보고 문제를 푸는 습관은 고쳐야겠다 라는 당연한 생각을 했다. 1234567891011121314151617class Solution { public boolean solution(String s) { boolean answer = true; if (s.length() == 4 || s.length() == 6) { for (int i=0; i&lt;s.length(); i++){ if((65&lt;= s.charAt(i) &amp;&amp; s.charAt(i) &lt;= 90) || (97&lt;= s.charAt(i) &amp;&amp; s.charAt(i) &lt;= 122)){ answer = false; break; } } return answer; } else answer = false; return answer; }}","link":"/2020/02/07/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%8B%A4%EB%A3%A8%EA%B8%B0-%EA%B8%B0%EB%B3%B8/"},{"title":"[프로그래머스] 나머지 한 점","text":"직사각형을 만드는데 필요한 4개의 점 중 3개만 주어질 때, 주어지는 3개의 점들은 모두 각 x축 y축에 평행 하도록 하는 좌표만 주므로, 만약 [[1,4],[3,4],[3,10]] 이 주어졌을 때 중복 되는 배열의 원소 수는 소거한다. 그럼 중복 되지 않는 수가 나머지 한 점 이 된다.그러므로 [1,10] 이 output으로 나와야 한다. 주어진 2차원 배열을 비정방형 행렬로 생각하여 풀어보자. 1234 x좌표 y좌표v = [[1, 4] [0][0] [0][1] [3, 4] == [1][0] [1][1] [3,10]] [2][0] [2][1] 1234567891011121314151617181920212223242526272829class Solution { public int[] solution(int[][] v) { int x, y; // x좌표값 찾기 if (v[0][0]==v[1][0]){ x = v[2][0]; } else if (v[0][0]==v[2][0]){ x = v[1][0]; } else x = v[0][0]; //y좌표값 찾기 if(v[0][1] == v[1][1]){ y = v[2][1]; } else if(v[0][1]==v[2][1]){ y = v[1][1]; } else y = v[0][1]; int[] answer = {x,y}; return answer; }} XOR 연산자 사용하여 문제해결 12345678910111213class Solution { public int[] solution(int[][] v) { int[] answer = {0,0}; //좌표는 총 3개가 입력으로 주어지므로 반복을 3번 돌린다. for (int i=0; i&lt;3; i++){ answer[0] ^= v[i][0]; answer[1] ^= v[i][1]; } return answer; }}","link":"/2020/01/22/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%82%98%EB%A8%B8%EC%A7%80-%ED%95%9C-%EC%A0%90/"},{"title":"[프로그래머스] 서울에서 김서방 찾기","text":"서울에서 김서방 찾기… 금방 풀었다라고 생각했고 테스트 통과까지 했다.하지만 정확성 테스트에서 털려버렸고 이유는 질문하기에서 금방 찾을 수 있었다. 그것은 바로 String 비교 문제에서 항등 연산자로 문제를 풀었던 것이다. 123456789101112131415//오답 코드 (정확성 테스트 실패)class Solution { public String solution(String[] seoul) { String answer = \"\"; int i = 0; for (i=0; i&lt;seoul.length; i++){ if (seoul[i] == \"Kim\"){ //문제의 그 부분 break; } answer = \"김서방은 \"+i+\"에 있다\"; } return answer; }} 자바에서 String을 비교할 때, .equals() 는 객체끼리 내용(값)을 비교할 수 있는 메소드이고(값 자체를 비교), == 는 객체의 참조(주소)값을 비교하는 연산자이다. 무심코 생각못하고 실전에서 이런 실수를 해버렸다면 정말 끔찍했을 것이다. 1234567891011121314//솔루션class Solution { public String solution(String[] seoul) { String answer = \"\"; String kim = \"Kim\"; int i = 0; for (i=0; i&lt;seoul.length; i++){ if (seoul[i].equals(kim)){ answer = \"김서방은 \"+i+\"에 있다\"; //띄어쓰기 주의 } } return answer; }}","link":"/2020/01/26/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%84%9C%EC%9A%B8%EC%97%90%EC%84%9C-%EA%B9%80%EC%84%9C%EB%B0%A9-%EC%B0%BE%EA%B8%B0/"},{"title":"[프로그래머스] 수박수박수박수박수박수?","text":"입력 n이 1일 땐 “수” 출력, n이 2이면 “수박”, 3이면 “수박수” … index 초기값을 1로 초기화 하고 반복문을 통해 i가 증가 할때마다 홀수, 짝수 판별을 한다. 만약 홀수면 “수”, 짝수면 “박”을 answer 에 추가해가면서 n번 반복한다. 12345678910111213class Solution { public String solution(int n) { String answer = \"\"; for (int i = 1; i &lt;= n; i++){ if (i % 2 == 1) { answer += \"수\"; } else { answer += \"박\"; } } return answer; }}","link":"/2020/02/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%88%98%EB%B0%95%EC%88%98%EB%B0%95%EC%88%98%EB%B0%95%EC%88%98%EB%B0%95%EC%88%98%EB%B0%95%EC%88%98/"},{"title":"[프로그래머스] 순열 검사","text":"배열의 크기가 4면 1부터 4까지 무조건 중복없이 숫자가 들어간다. arr = [4,2,3,1] 하지만 원소의 순서는 뒤죽박죽이 되어 있을 수 있다. 그러므로 java.util.Arrays를 import 하고 매개변수로 들어오는 arr 배열을 sort 시켜준다. 그리고 arr의 index와 index 내부의 원소가 같은 지 판별하는 알고리즘을 짜도록 한다. 12345678910111213141516import java.util.Arrays;class Solution { public boolean solution(int[] arr) { boolean answer = true; Arrays.sort(arr); for (int i=0; i&lt;arr.length; i++){ //배열의 첫번째 방(0번째 방)에 원소 1이 있는지부터 판별 if(arr[i]!=i+1) { answer = false; break; } } return answer; }}","link":"/2020/01/22/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%88%9C%EC%97%B4-%EA%B2%80%EC%82%AC/"},{"title":"[프로그래머스] 자릿 수 더하기","text":"컴퓨터과학 수업에서 새로운 언어를 배울 때 지겹도록 짜본 코드…하지만 간과하지 말자. 이런 간단한 것도 생각이 안날 수 있으니까. 123456789101112import java.util.*;public class Solution { public int solution(int n) { int answer = 0; while (n!=0) { answer += n % 10; n /= 10; } return answer; }}","link":"/2020/01/22/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%9E%90%EB%A6%BF-%EC%88%98-%EB%8D%94%ED%95%98%EA%B8%B0/"},{"title":"[프로그래머스] 시저 암호","text":"아스키를 잘 다룬다면 쉬운 문제겠지만 잘 못다룬다면 어려운 문제일 수 있겠다. 문자열과 정수를 입력받아 정수 만큼 다음 문자로 밀어주는 (예를 들면 A가 2만큼 이동하면 C) 카이사르 암호 문제이다. 이 문제에서 잘 생각해야 하는 부분은 알파벳에서 소문자 대문자를 포함하지 않는다면 A 부터 Z까지 모두 26자 이다. 여기서 Z에서 정수 1을 받게 되면 A로 다시 돌아와야 한다. 그렇기 때문에 입력 받은 n을 밀어낼 자리 수 계산을 위해 n = n % 26 을 이용. 26(Z)이 넘어가게 되면 나머지 값 1 , 즉 A 부터 다시 출력 할 수 있게 한다. 문자열 s의 길이 만큼 반복하고, char 변수에 문자열에서 문자 하나를 받아 소문자, 대문자를 판별한다. 사용한 라이브러리 함수는 isLowerCase(), isUpperCase() 이다. boolean 타입이며 각각 소문자면 해당 문자가 소문자, 대문자면 true, false를 내보낸다. 그 후 이동시킬 알파벳 ch에서 ‘A’ 또는 ‘a’를 빼고 밀어줄 n값을 더한 후 전체 알파벳 수(26)로 나눈 나머지를 구하면 이동할 거리가 완벽하게 계산된다. 그걸 다시 초기값 ‘A’ 또는 ‘a’에 더해주면 ch 문자로부터 n만큼 이동한 알파벳이 나오게 된다. 마지막으로 입력 받았을 때 공백이 포함 된 문자열이 있으므로 공백 (ascii 값 32) 처리로 마무리 한다. ascii를 계산하는 핵심 공식을 잘 알아둬야겠다. 1234567891011121314151617181920class Solution { public String solution(String s, int n) { String answer = \"\"; n = n % 26; for (int i=0; i&lt;s.length(); i++){ char ch = s.charAt(i); if (Character.isLowerCase(ch)) { //소문자면 ch = (char)((ch-'a'+n) % 26 + 'a'); //핵심 공식 } else if (Character.isUpperCase(ch)) { //대문자면 ch = (char)((ch-'A'+n) % 26 + 'A'); //핵심 공식 } else if (ch == 32) { //받은 문자가 공백일 때 answer += \"\"; } answer = answer + ch; } return answer; }}","link":"/2020/02/25/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%8B%9C%EC%A0%80-%EC%95%94%ED%98%B8/"},{"title":"[프로그래머스] 직사각형 별 찍기","text":"이중 for문을 잘 이해하라! 12345678910111213141516import java.util.Scanner;public class Solution { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a = sc.nextInt(); int b = sc.nextInt(); for (int i=0; i&lt;b; i++){ for (int j=0; j&lt;a; j++){ System.out.print(\"*\"); } System.out.println(); } }}","link":"/2020/01/26/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%A7%81%EC%82%AC%EA%B0%81%ED%98%95-%EB%B3%84-%EC%B0%8D%EA%B8%B0/"},{"title":"[프로그래머스] 짝수와 홀수","text":"num이 짝수면 Even 홀수면 Odd 123456789101112class Solution { public String solution(int num) { String answer = \"\"; if (num % 2 == 0){ answer = \"Even\"; } else{ answer = \"Odd\"; } return answer; }}","link":"/2020/01/26/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%A7%9D%EC%88%98%EC%99%80-%ED%99%80%EC%88%98/"}],"tags":[{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"명령어","slug":"명령어","link":"/tags/%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"name":"협업","slug":"협업","link":"/tags/%ED%98%91%EC%97%85/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"Hypertext","slug":"Hypertext","link":"/tags/Hypertext/"},{"name":"백준","slug":"백준","link":"/tags/%EB%B0%B1%EC%A4%80/"},{"name":"BOJ","slug":"BOJ","link":"/tags/BOJ/"},{"name":"알고리즘","slug":"알고리즘","link":"/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Stack","slug":"Stack","link":"/tags/Stack/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Blog","slug":"Blog","link":"/tags/Blog/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"plugin","slug":"plugin","link":"/tags/plugin/"},{"name":"안드로이드","slug":"안드로이드","link":"/tags/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C/"},{"name":"intent","slug":"intent","link":"/tags/intent/"},{"name":"데이터통신","slug":"데이터통신","link":"/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%86%B5%EC%8B%A0/"},{"name":"코틀린","slug":"코틀린","link":"/tags/%EC%BD%94%ED%8B%80%EB%A6%B0/"},{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"},{"name":"SEO","slug":"SEO","link":"/tags/SEO/"},{"name":"액션바","slug":"액션바","link":"/tags/%EC%95%A1%EC%85%98%EB%B0%94/"},{"name":"상단바","slug":"상단바","link":"/tags/%EC%83%81%EB%8B%A8%EB%B0%94/"},{"name":"Gradle","slug":"Gradle","link":"/tags/Gradle/"},{"name":"SHA1","slug":"SHA1","link":"/tags/SHA1/"},{"name":"SHA256","slug":"SHA256","link":"/tags/SHA256/"},{"name":"조회수","slug":"조회수","link":"/tags/%EC%A1%B0%ED%9A%8C%EC%88%98/"},{"name":"방문자수","slug":"방문자수","link":"/tags/%EB%B0%A9%EB%AC%B8%EC%9E%90%EC%88%98/"},{"name":"권한","slug":"권한","link":"/tags/%EA%B6%8C%ED%95%9C/"},{"name":"permission","slug":"permission","link":"/tags/permission/"},{"name":"manifest","slug":"manifest","link":"/tags/manifest/"},{"name":"자료구조","slug":"자료구조","link":"/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"성능분석","slug":"성능분석","link":"/tags/%EC%84%B1%EB%8A%A5%EB%B6%84%EC%84%9D/"},{"name":"최악의경우","slug":"최악의경우","link":"/tags/%EC%B5%9C%EC%95%85%EC%9D%98%EA%B2%BD%EC%9A%B0/"},{"name":"Time Complexity","slug":"Time-Complexity","link":"/tags/Time-Complexity/"},{"name":"빅오표기법","slug":"빅오표기법","link":"/tags/%EB%B9%85%EC%98%A4%ED%91%9C%EA%B8%B0%EB%B2%95/"},{"name":"빅오메가표기법","slug":"빅오메가표기법","link":"/tags/%EB%B9%85%EC%98%A4%EB%A9%94%EA%B0%80%ED%91%9C%EA%B8%B0%EB%B2%95/"},{"name":"빅세타표기법","slug":"빅세타표기법","link":"/tags/%EB%B9%85%EC%84%B8%ED%83%80%ED%91%9C%EA%B8%B0%EB%B2%95/"},{"name":"배열","slug":"배열","link":"/tags/%EB%B0%B0%EC%97%B4/"},{"name":"array","slug":"array","link":"/tags/array/"},{"name":"추가","slug":"추가","link":"/tags/%EC%B6%94%EA%B0%80/"},{"name":"검색","slug":"검색","link":"/tags/%EA%B2%80%EC%83%89/"},{"name":"제거","slug":"제거","link":"/tags/%EC%A0%9C%EA%B1%B0/"},{"name":"연결리스트","slug":"연결리스트","link":"/tags/%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8/"},{"name":"list","slug":"list","link":"/tags/list/"},{"name":"linkedlist 추가","slug":"linkedlist-추가","link":"/tags/linkedlist-%EC%B6%94%EA%B0%80/"},{"name":"프로그래머스","slug":"프로그래머스","link":"/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"정렬","slug":"정렬","link":"/tags/%EC%A0%95%EB%A0%AC/"},{"name":"sort","slug":"sort","link":"/tags/sort/"},{"name":"copyOfRange()","slug":"copyOfRange","link":"/tags/copyOfRange/"},{"name":"long","slug":"long","link":"/tags/long/"},{"name":"integer","slug":"integer","link":"/tags/integer/"},{"name":"parse","slug":"parse","link":"/tags/parse/"},{"name":"ascii","slug":"ascii","link":"/tags/ascii/"},{"name":"atoi","slug":"atoi","link":"/tags/atoi/"},{"name":"equals()","slug":"equals","link":"/tags/equals/"},{"name":"&#x3D;&#x3D;","slug":"","link":"/tags/"},{"name":"isLowerCase()","slug":"isLowerCase","link":"/tags/isLowerCase/"},{"name":"isUpperCase()","slug":"isUpperCase","link":"/tags/isUpperCase/"}],"categories":[{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"HTML&#x2F;CSS","slug":"HTML-CSS","link":"/categories/HTML-CSS/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"BOJ","slug":"Algorithm/BOJ","link":"/categories/Algorithm/BOJ/"},{"name":"Data Structure","slug":"Data-Structure","link":"/categories/Data-Structure/"},{"name":"Programmers","slug":"Algorithm/Programmers","link":"/categories/Algorithm/Programmers/"}]}