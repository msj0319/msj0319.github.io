{"pages":[{"title":"about","text":"Footprints Education : 상명대학교 컴퓨터과학과 (7학기 재학 중 / 2021년 8월 졸업 예정) Github URL: https://github.com/msj0319 Career : 멋쟁이 사자처럼 (대외 동아리) 2020.01 ~ 2020.12 8기 운영진 활동, 8기 신입부원 과제수행 및 멘토링 진행 2019.01 ~ 2019.12 7기 신입부원 활동, Android/Kotlin Study, Hackathon 참여출처: 멋쟁이 사자처럼 공식 유튜브 채널 디지털 융복합 코로나19 관련 지역사회 문제해결 분야 창업 공모전 3위 (2020.09.28) 과학교육키트 관련 사업 엑시트 사이언스 창업 (2020.09.29 ~ ) ‘R’시큐어 주식회사 품질기획팀 인턴 2019.07.17 부터 2020.01.16 까지 (총 6개월) QA 업무 보조 및 제품 테스트 업무 진행 테스트 케이스 고도화 PC 제품, 모바일(Android, iOS) 제품 테스트 모바일 OS, 버전별 Android OS 루팅, iOS 탈옥 테스트를 통한 제품 취약점 발견 루팅 수행 과정 방법을 상세 기술한 문서 작성, 업데이트 전사 개발 팀 및 품질기획팀 내 문서 공유 경험 JIRA 소프트웨어를 사용한 이슈 등록 및 관리 경험 제품 별 증적자료 문서화 경험 Projects : 핸드폰 초기 불량 테스트 애플리케이션 https://github.com/msj0319/OneQTesterApp-Project (원큐테스터) 타인과 이야기를 공유하는 고민 상담 애플리케이션 (PlaNetwork) https://github.com/msj0319/Planetwork 소프트웨어공학 팀 프로젝트 (할뚜이따) https://github.com/msj0319/Halttuetta 상명대학교 학생들을 위한 정보 공유 랜덤 채팅 서비스 (MISO/ 미소) https://github.com/msj0319/miso_capstone_design_project출처 : 한국대학신문(http://news.unn.net/news/articleView.html?idxno=236324) Etc : 기술 블로그 운영 https://msj0319.github.io/","link":"/about/index.html"}],"posts":[{"title":"[Git] Branch 관련 명령어","text":"브랜치 생성 1git checkout -b &lt;브랜치 이름&gt; 다른 브랜치로 전환 1git checkout &lt;브랜치 이름&gt; 원본 브랜치 (master 브랜치)로 전환 1git checkout master 브랜치에 push 하기 123git add .git commit -m &quot;커밋 내용&quot;git push origin &lt;브랜치 이름&gt; 특정 브랜치 소스코드 Clone 받기 1git clone -b &lt;브랜치 이름&gt; --single-branch &lt;리포지토리 주소&gt; 원격(remote) 브랜치 삭제하기 1git push origin --delete &lt;브랜치 이름&gt; 내 로컬 저장소(내 컴퓨터)에서 개발 중인 로컬 브랜치 삭제하기 1git branch -d &quot;브랜치 이름&quot;","link":"/2020/07/30/Git-01-Git-%EB%AA%85%EB%A0%B9%EC%96%B4-%EB%A9%94%EB%AA%A8/"},{"title":"[HTML&#x2F;CSS] 01. HTML&#x2F;CSS 기초","text":"본 내용은 필자가 부스트코스 웹UI 개발 코스를 수강 후 공부하기 위해 정리한 것임을 알려드립니다. HTML의 이해HTML 소개- Hypertext Markup Language 의 약자. 웹페이지를 만드는 언어 Hypertext란, 텍스트를 초월하는, 텍스트 그 이상이라는 말. : Link Markup Language : 정보를 구조적으로 표현 가능한 언어. : HTML 파일확장자는 .html 영국의 물리학자 팀 버너스 리가 최초로 제안하여 개발됨. HTML 문법태그 HTML은 태그의 집합 통상적인 태그의 의미는 무언가를 표시하기 위한 꼬리표, 이름표라는 의미 기본적으로 &lt;, &gt; 기호로 표현하며, 괄호안에 태그 이름이 들어간다. 시작 태그와 종료 태그로 이루어져있고 종료 태그는 &lt;/&gt; 기호가 붙는다. 시작 태그와 종료 태그 사이에 실제 화면에 나타나는 내용이 위치된다. 12&lt;h1&gt; Hello, World &lt;/h1&gt;&lt;!--h1 태그를 사용하여 Hello, World를 출력한다.--&gt; 내용을 포함한 전부를 ‘요소’라고 한다. 각 태그에는 의미가 있고, 각 의미에 맞게 사용해야 한다. XML, SGML, XHTML에도 태그를 사용한다. 속성 Attribute HTML 태그들은 모두 속성을 갖고 있음 속성은 태그에 추가적으로 정보를 재공하거나, 태그의 동작이나 표현을 제어할 수 있는 설정값을 의미한다. 이름과 값으로 이루어짐 123&lt;h1 id=&quot;title&quot;&gt;Hello, World&lt;/h1&gt;&lt;!--시작 태그에서 태그 이름 뒤에 공백으로 구분--&gt;&lt;!--속성이름=&quot;속성 값&quot;으로 표현--&gt; Equal 사인 뒤에는 절대 공백이 와선 안된다. 하나의 태그에 여러 속성을 선언할 수 있다. 12&lt;h1 id=&quot;title&quot; class=&quot;test&quot;&gt;Hello, World&lt;/h1&gt;&lt;!--속성들의 순서는 중요하지 않다.--&gt; 속성은 종류에 따라 모든 태그에 사용가능한 글로벌 속성, 특정 태그에만 사용가능한 속성으로 구분된다. 선택적으로 쓸 수 있는 속성, 특정 태그에서 필요한 필수 속성으로 구분된다. 태그의 중첩 태그는 중첩이 가능함. 내부에 선언되는 태그는 반드시 부모 태그를 벗어나면 안됨. 온전히 부모 태그 안에서 시작되고 끝나야 한다. 태그 안에 중첩이 얼마나 되는지, 어떤 태그가 중첩이 되던 상관없다. 경우에 따라선 정해진 태그들만 중첩이 가능한 경우도 있다. 빈 태그 시작 태그만 존재하고 종료 태그가 존재하지 않는 태그 종료 태그가 존재하지 않기 때문에 내용이 들어갈 수 없다. 입력하는 내용만 비어있고, 속성을 통해 화면을 나타내거나 화면에 표시되지 않더라도 다른 용도로 사용되는 태그 브라우저가 작성자 대신 내용을 그려야 하는 경우에 사용한다. 이미지, 비디오 등 외부 리소스 삽입 시. 브라우저가 내용을 대체한다라는 뜻으로 Replacement Tag라고 불린다. 공백 기본적으로 HTML은 두 칸 이상의 공백을 모두 무시한다.123456&lt;h1&gt;Hello, HTML&lt;/h1&gt;&gt;&lt;h1&gt;Hello, HTML&lt;/h1&gt;&lt;h1&gt; Hello, HTML&lt;/h1&gt; 세가지 요소는 모두 동일한 결과를 출력 한줄이 아닌 여러 줄의 개행을 모두 무시한다. 주석 화면에 노출되지 않고 메모의 목적으로 사용. 개발자들을 위한 기능임. 문서의 기본구조12345678910111213141516&lt;!--문서가 어떤 버전으로 작성되었는지 브라우저에게 알려주는 선언--&gt;&lt;!DOCTYPE html&gt; &lt;!--해당 문서의 언어--&gt;&lt;html lang='ko'&gt; &lt;!--head부 : 문서의 기본정보 설정, CSS, Javascript 연결 담당--&gt; &lt;head&gt; &lt;!--문자의 인코딩 방식 설정 속성--&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;!--브라우저 화면 탭바에 노출되는 내용 : title--&gt; &lt;title&gt;HTML&lt;/title&gt; &lt;/head&gt; &lt;!--body부: 실제 화면에 출력되는 부분--&gt; &lt;body&gt; &lt;h1&gt;Hello, HTML&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt;","link":"/2021/01/04/HTML-CSS-01-HTML%EC%9D%98-%EA%B8%B0%EB%B3%B8/"},{"title":"[BOJ] 10828번 - 스택","text":"학부생 때 배웠던 스택 자료구조 이론을 토대로 스택 배열 생성, push , pop 연산 등을 구현해보는 문제였다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Scanner;public class Main { public static void main(String[] args){ Scanner sc = new Scanner(System.in); int num = sc.nextInt(); int top = -1; int[] stack = new int[num]; for (int i=0; i&lt;num; i++){ String input = sc.next(); if (input.equals(\"push\")){ stack[++top] = sc.nextInt(); } else if (input.equals(\"pop\")) { if (top == -1) { System.out.println(-1); } else { System.out.println(stack[top]); top--; } } else if (input.equals(\"size\")) { System.out.println(top+1); } else if (input.equals(\"empty\")) { if (top == -1){ System.out.println(1); } else { System.out.println(0); } } else if (input.equals(\"top\")){ if (top == -1) { System.out.println(-1); } else { System.out.println(stack[top]); } } } }}","link":"/2020/02/12/BOJ-10828%EB%B2%88-%EC%8A%A4%ED%83%9D/"},{"title":"[Hexo Blog] Markdown 플러그인 설치","text":"마크다운은 간단한 인라인 코드를 작성할 때 백틱을 이용한다. 1`(넣을 내용)` 근데 잘 쓰고 있던 중 어떤 md 파일은 먹히는데 새로 작성하는 파일에선 되지 않는 현상을 발견했다. 구글링을 통해 삽질을 해본 결과 기본 hexo는 원래 해당 태그를 지원하지 않는다는 사실을 어느 블로그를 통해 알게 되었고 당장 hexo 용 마크다운 플러그인을 설치했다. 참조 : https://d2fault.github.io/2018/07/03/20180703-smart-posting/ Installhttps://github.com/CHENXCHEN/hexo-renderer-markdown-it-plushexo가 설치 된 루트 폴더 (블로그 theme 상단 경로)에 아래 npm 명령을 입력한다. 12npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it-plus --save _config.yml 설정1234567891011#Markdown 플러그인 설치markdown_it_plus: highlight: true html: true xhtmlOut: true breaks: true langPrefix: linkify: true typographer: quotes: “”‘’ pre_class: highlight _config.yml 파일 최하단에 다음 구문을 넣어 설정한다.","link":"/2020/01/28/Hexo-Blog-Markdown-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-%EC%84%A4%EC%B9%98/"},{"title":"[안드로이드][Kotlin] View 형식에 따른 Intent 데이터 주고받기","text":"졸업 프로젝트를 위해 프로토타입을 만들던 중 될 것 같던 부분이 안되어 해결 후 정리해보았다. 하나의 액티비티에서 데이터를 다른 액티비티로 보내기 위해선 intent 객체를 만들어 putExtra() 메소드로 데이터를 묶어 보낸다. 그리고 받는 액티비티에선 getXXExtra() (XX는 자료형) 메소드로 데이터를 받는 것이 기본적이다. 간단한 회원가입 레이아웃을 만들고, 사용자가 Plain Text View에 학번(StudentID)을 입력한다. 제출 버튼을 누르면 해당 액티비티 VerifyEmailActivity 에 보내고, 동일한 Plain Text 에 입력했던 아이디가 그대로 나타나는 로직을 구현하고 싶었다. 사용자가 한번 더 입력할 필요없이 한번 입력했던 학번이 자동으로 표시되도록 만들고 싶었다. 1234// 데이터 보내는 액티비티val intent = Intent (this, VerifyEmailActivity::class.java)intent.putExtra(&quot;studentID&quot;,studentID.text.toString())startActivity(intent) 123// 데이터 받는 액티비티var studentID = intent.getStringExtra(&quot;studentID&quot;)TextView.text = studentID //오류가 난 부분 TextView는 사용자의 직접 입력없이 설정한 text만 설정하면 보여지는 View이기에 이렇게 간단하게 원하는 Text를 인텐트로 받아 설정할 수 있었다. 하지만 사용자가 입력한 Text가 인텐트로 보냈을 시 받는 View의 상태가 만약 똑같은 Plain Text라면 다음 코드 처럼 작성해야 한다는 것을 알게 되었다. 12345678//코드 수정 Plain Text -&gt; Plain Textvar studentID = intent.getStringExtra(&quot;studentID&quot;)if (!studentID.isNullOrEmpty()) { studentIDText.setText(studentID) //setText method 사용 } else { ... }","link":"/2020/03/11/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-View-%ED%98%95%EC%8B%9D%EC%97%90-%EB%94%B0%EB%A5%B8-Intent-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A3%BC%EA%B3%A0%EB%B0%9B%EA%B8%B0/"},{"title":"[Hexo Blog] 구글 사이트 등록 및 검색엔진 최적화(SEO)","text":"Hexo 블로그를 만들었다면 구글에 키워드 서칭 시 내 블로그가 검색이 잘 되도록 하는 과정을 알아보자. 검색 최적화구글 같은 검색 엔진을 주로 서비스하는 사이트들은 크롤링 이라고 하는 작업을 통해 여러 웹사이트나 블로그 들의 정보를 검색 엔진에 수집해서 사람들이 검색을 할 시 해당 사이트들을 사용자들에게 노출시킨다고 한다. 일단 기술 블로그만 만들면 장땡일 줄 알았는데 막상 이런 작업을 하려고 하니 막막하지만 블로그를 좀 더 개선할 수 있는 방법이기 때문에 바로 시작한다.구글에 Hexo만 검색해도 검색엔진 최적화 라는 방법들을 여러 사람들이 쓰는 것을 알 수 있었는데, 줄여서 SEO 라고 한다. 즉 Search Engine Optimization 은 검색엔진에 맞게 사이트를 제작, 운영하는 과정 전부를 말한다.SEO 과정을 시작하기 위해서는 Hexo 프로젝트에 몇가지 플러그인 설치가 필요하다. 플러그인 설치hexo-auto-canonical메타 태그 중 canonical 속성을 대표 URL이라 뜻하고 각 포스트마다 자동으로 표준 링크를 만들어 준다. 설치 npm-install --save hexo-auto-canonical 설정설정은 내 블로그 테마 기준, theme 폴더 아래의 layout/common/head.ejs 파일에서 제일 하단에 구문을 추가한다. 12&lt;!--Canonical : 유사하거나 중복된 페이지의 표준 페이지 정의--&gt;&lt;%- autoCanonical(config, page) %&gt; head.ejs 구문을 만지작하고 deploy 하니 head 태그 아래에 &lt;link rel=&quot;canonical&quot; href=&quot;https://msj0319.github.io/&quot;&gt; 라고 설정이 된 것을 확인할 수 있다. 메타 태그 (meta tag)는 해당 웹 페이지의 정보를 담은 태그로 &lt;head&gt; 태그 안에 있다고 한다. 이 메타 태그가 잘 들어가 있어야 검색엔진이 이 사이트를 잘 인식해서 수집이 잘된다고 한다. 참조 : https://futurecreator.github.io/2016/06/15/hexo-google-site-search-console-analytics/ 웹 개발 쪽은 잘 몰랐는데 여러 ejs 파일들이 이런 식으로 각자 할일들이 있는 모양새인듯 하다. 시간나면 공부해 봐야겠다. hexo-autofollow해당 포스트에서 참고하고 있는 외부링크에 대해 nofollow 속성을 자동으로 추가하는 플러그인이다. 앞서 언급했듯이 검색엔진은 사람들이 서칭활동을 하는데에 있어 원하는 웹페이지를 되도록 많이 수집하는데 이런 크롤링 작업을 하는 로봇을 크롤러 또는 구글봇이라고 한다. 이런 로봇에게 어떤 페이지는 수집하지 말라고 얘기할 필요가 있기 때문에 이런 기능이 필요한 것이다. 설치 npm install hexo-autonofollow --save 설정 (theme/_config.yml)12345nofollow: enable: true exclude: - exclude_1.com #예외처리 할 사이트 등록 - exclude_2.com hexo-generator-seo-friendly-sitemapSitemap 생성기, 사이트맵을 등록하면 크롤링 작업을 하는 봇들이 좀 더 효율적으로 크롤링 작업을 할 수 있게 도와주는 역할을 한다. 설치 npm-install hexo-generator-seo-friendly-sitemap --save 설정 (theme/_config.yml)123456# 검색 엔진에서 크롤링 할 페이지들을 결정해주는 xml 파일 생성sitemap: path: sitemap.xml #블로그 주소/sitemap.xml #여기까지만 쓴다. 아래는 옵션 tag: true #Defualt: true category: true #Default: true tag 속성 : sitemap에 tag 정보 포함 여부category 속성 : sitemap에 마찬가지로 카테고리 포함 여부 (실제로 root 폴더 내부에 sitemap.xml 파일들이 생성된 것이 보인다.) hexo-generator-feed자동으로 Atom 1.0 또는 RSS2.0 피드 생성해주는 플러그인이다. 설치 npm install hexo-generator-feed --save 설정 (theme/_config.yml)123456789feed: type: rss2 #atom / rss2 path: rss2.xml #(Defult: atom.xml/rss2.xml) - 네이버에선 atom 미지원으로 인해 rss2로 설정 limit: 20 #공개할 rss feed 수 # 기본적으로 여기 까지만 쓴다. 아래는 옵션 hub: content: content_limit: 140 #요약 글자 수 content_limit_delim: '' root/_config.yml12# Path or URL to RSS atom.xmlrss: /rss2.xml #feed에서 등록한 rss 주소 입력 hexo-generator-robotstxt설치 npm install hexo-generator-robotstxt --save 설정1234robotstxt: User-agent: \"*\" Allow: / Sitemap: https://msj0319.github.io/sitemap.xml Sitemap 속성엔 미리 Sitemap 플러그인 설치 후 설정한 사이트맵의 주소를 넣는다. 그 뜻은 robots 생성 플러그인 설치를 위해선 사이트맵 플러그인 설치가 선행되어야 한다.설정이 모두 끝난 후 Deploy를 하면 모든 검색엔진 최적화를 위한 플러그인 설치는 끝난다.","link":"/2020/02/14/Hexo-Blog-%EA%B5%AC%EA%B8%80-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EB%93%B1%EB%A1%9D-%EB%B0%8F-%EA%B2%80%EC%83%89%EC%97%94%EC%A7%84-%EC%B5%9C%EC%A0%81%ED%99%94-SEO/"},{"title":"[안드로이드] 앱 상단바 없애기","text":"프로젝트의 values 디렉토리 내부의 styles.xml에 아래 구문을 추가한다. 1234567891011121314&lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.DarkActionBar\"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt; &lt;!-- 상단바 없애기 --&gt; &lt;item name=\"windowActionBar\"&gt;false&lt;/item&gt; &lt;item name=\"windowNoTitle\"&gt;true&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt;","link":"/2020/03/06/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%95%B1-%EC%83%81%EB%8B%A8%EB%B0%94-%EC%97%86%EC%95%A0%EA%B8%B0/"},{"title":"[안드로이드] 앱 프로젝트에서 SHA-1, SHA-256 인증서 지문 찾기","text":"작업 Window에서 오른쪽에 보면 Gradle로 작은 탭이 있는 것을 볼 수 있다.그걸 누르고 app-&gt;Tasks-&gt;signingReport 를 더블 클릭하면 아래 콘솔 창에 원하는 정보가 출력된다.","link":"/2020/03/08/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%95%B1-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90%EC%84%9C-SHA-1-SHA-256-%EC%9D%B8%EC%A6%9D%EC%84%9C-%EC%A7%80%EB%AC%B8-%EC%B0%BE%EA%B8%B0/"},{"title":"[Hexo Blog] 블로그 방문자 및 조회수 카운팅 기능 넣기 (Busuanzi)","text":"해당 포스트는 Hexo theme 중 icarus 테마에 적용한 내용입니다. 지원이 되지 않거나, 설정 방법에서 약간의 차이가 있을 수 있습니다. 간단하게 블로그 하단에 방문하신 분들이 몇 명이나 되었는지, 또한 글을 얼마나 봐주셨는지에 대해 간단히 표시할 수 있는 기능을 설정하는 법을 알아보자. Busuanzihexo 프레임워크가 애초에 중국에서 만들어졌다보니 웹페이지에 필요한 라이브러리 중 방문자, 조회수 카운팅 기능도 중국 라이브러리라는 것을 알게되었다. Busuanzi 공식 사이트 : https://busuanzi.ibruce.info/ Busuanzi 사용 법 기술 사이트 : http://ibruce.info/2015/04/04/busuanzi/ 설정먼저 theme\\_config.yml 로 들어가 busuanzi 섹션을 찾고 해당 기능을 true로 상태를 활성화 시킨다.그 다음 theme\\layout\\common\\footer.ejs 에서 몇가지 구문을 넣어준다. 123456789&lt;% if (busuanzi) { %&gt; &lt;!--만약 busuanzi 가 활성화됐으면--&gt; &lt;br&gt; &lt;span id=\"busuanzi_container_site_pv\"&gt; 총 조회 &lt;span id=\"busuanzi_container_site_pv\"&gt;&lt;/span&gt; 회 &lt;/span&gt; | &lt;span id=\"busuanzi_container_site_uv\"&gt; 총 방문자 &lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt; 명 &lt;/span&gt; &lt;% } %&gt; 아직 많은…분들께서 방문해주시지 못했지만 이렇게 기능이 추가된 것을 볼 수 있다.열심히 노력하자!","link":"/2020/02/15/Hexo-Blog-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%B0%A9%EB%AC%B8%EC%9E%90-%EB%B0%8F-%EC%A1%B0%ED%9A%8C%EC%88%98-%EC%B9%B4%EC%9A%B4%ED%8C%85-%EA%B8%B0%EB%8A%A5-%EB%84%A3%EA%B8%B0/"},{"title":"[안드로이드] 앱 인터넷 권한 설정","text":"Android.xml의 &lt;manifest&gt; 태그 내부에 해당 구문 추가. 12&lt;!--인터넷 권한 설정--&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;&gt;&lt;/uses-permission&gt;","link":"/2020/03/08/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%95%B1-%EC%9D%B8%ED%84%B0%EB%84%B7-%EA%B6%8C%ED%95%9C-%EC%84%A4%EC%A0%95/"},{"title":"[자료구조] 02. 성능분석","text":"본 내용은 필자가 학부 자료구조 수업내용을 공부하기 위해 정리한 것임을 알려드립니다. 2-1. 성능이란 무엇인가?어떤 자료구조가 좋은 자료구조인지 쉽게 생각해보려면 내가 여러 지도 앱에서 원하는 경로를 검색할 때를 생각해보면 편하다. 만약 카카오 맵 앱에서 서울역부터 집까지 가는 경로를 검색할 때는 0.1초가 걸리고 네이버 지도 앱에서 동일한 경로를 검색할 때는 0.2초가 걸린다고 가정하자. (물론 예시일 뿐 네이버 앱이 안좋은 서비스라는 것은 아니다.) 동일한 입력(출발지: 서울역, 도착지: 우리 집)을 주었을 때 빠른 시간 내에 정답(가장 빠른 경로)을 출력하는 앱이 가장 좋은 앱이 되고, 카카오 맵 앱은 좋은 자료구조로 짜여있다고 말할 수 있다. 결과적으로 성능이 좋다 (재차 강조하지만 네이버 지도 앱을 비하하려는 목적이 아니다.) 그럼 성능이란 무엇일까? 성능(Performance) 또는 효율(Efficient)이라고 말할 수 있다. 동일한 성과(Soluton)를 도출하기 위해서 요구되는 자원(Resource)의 크기 Performance = solution / resource 효과적(effective)이란 투입하는 자원(Resource)이 같을 때 얼마나 많은 solution을 도출하는가? 성능의 세가지 측면 최선의 경우 (Best Case) 평균의 경우 (Average Case) 최악의 경우 (Worst Case) 시스템에 과도한 입력(사용자의 요청)이 들어와도 적어도 ‘해당 시간’에 처리한다. '보장'의 의미 성능은 솔루션/자원이다. 그 중 분모에 해당하는 자원(리소스)은 컴퓨터의 자원을 뜻하는데, 컴퓨터의 자원이라 함은 메모리와 CPU가 있다. 무어의 법칙의 한계가 올 정도로 기술은 급속도로 변화되면서 공정 세밀화와 실리콘 기반 반도체에 한계가 찾아왔다. 20nm 이후로는 기술적 구현 측면보다는 경제성의 측면에서 무어의 법칙이 멈출거라고 보는 전문가들이 많기 때문에 CPU의 성능은 좋아져도 가격이 어마무시하게 뛰게 될것이다. 반대로 메모리는 용량은 기하급수적으로 커지고 가격은 점점 싸지고 있다. 공간 복잡도 (Space-Complexity)“특정한 프로그램을 수행하는 데 요구되는 메모리” 공학적으로 생각해볼 때 메모리의 Cost는 낮아지고 용량은 커지고 있으므로 공간복잡도는 성능을 측정할 때 고려할 요소가 되지 않는다. 시간 복잡도 (Time-Complexity)“특정한 프로그램을 수행하는 데 요구되는 시간” 시간복잡도로 시스템의 성능을 측정한다. 2-2. 점근적 분석법 (Asymptotic Complexity) 성능은 입력의 크기에 따라에 결정됨 실제로 프로그램의 성능을 공정하게 판단하기 위해서는 입력의 크기만으로 판단한다. n : 입력의 크기 시간 복잡도를 n(입력)의 함수로 표현 : f(n) 시간 복잡도는 매우 큰 입력에 대해서 측정한다. 동일한 크기의 입력 처리 시 같은 성능 함수 g(n)을 통한 f(n)의 성능 표현 g(n) &gt;= f(n) g(n) 함수가 f(n) 함수보다 증가율이 크다면 g(n)은 f(n)보다 성능이 나쁘다. g(n)은 f(n)보다 시간이 더 많이 걸린다. 최악의 경우에도 f(n)은 g(n)보다 좋다. f(n)의 upper bound(상한)는 g(n)이다. f(n)의 최악의 경우는 g(n)이다.","link":"/2020/05/08/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-02-%EC%84%B1%EB%8A%A5%EB%B6%84%EC%84%9D/"},{"title":"[자료구조] 03. Big-O 표기법","text":"본 내용은 필자가 학부 자료구조 수업내용을 공부하기 위해 정리한 것임을 알려드립니다. 2-3. Big-O 표기법 f(n) = O(g(n)) 입력의 크기가 무한히 커질 때, 입력이 특정한 입력(n0)보다 크기만 하면 f(n)은 항상 M * g(n) 보다 작거나 같다를 만족하는 특정한 입력(n0)과 M이 존재한다. f(n) &lt;= g(n) f(n) &lt;= g(n) for n0 &lt; n f(n) &lt;= M*g(n) for n0 &lt; n 동일한 비율로 증가하는 함수를 허용하기 위해 상수 M을 허용한다. 성질 1어떤 n &gt; n1 에 대해서 g1(n) &lt; g2(n) 이라면 f(n) = O(g1(n))은 f(n) = O(g2(n))을 의미한다. f(n) = O(g(n))이고, g1(n)보다 g2(n) 함수가 더 성능이 좋지 않을 때, f(n)의 입장에서도 g2(n)은 upper bound다. 성질 2어떤 상수 k에 대해서 f(n) = O(k*g(n))이라면, f(n) = O(g(n))이다. k는 생략 가능하다. 성질 3f(n) = O(g1(n) + g2(n))이고, 어떤 n &gt; n1에 대해서 g1(n) &lt; g2(n)이라면 f(n) = O(g2(n))이다. 두 함수 중 낮은 계수는 생략되고, 높은 계수(성능이 좋지않은)가 곧 빅 오 표기법 함수로 대표된다. 빅 오메가(Big-Omega) 표기법 빅 오 표기법과 반대되는 의미 f(n) = O(g(n)) 일 때, g(n) = Ω(f(n)) g(n)은 f(n)보다 느리다. g(n)의 lower bound는 f(n)이다. 빅 세타(Big-Theta) 표기법 동일한 n에 따라 f(n)과 g(n)이 서로 근사치의 비율로 증가할 때 f(n) = O(g(n)) 과 g(n) = O(f(n)) 일 때. f(n) = Θ(g(n)) 2-4. Big-O 표기법의 예 상수 시간 복잡도 (constant time complex) f(n) = O(1) 반복문을 이용한 별 찍기 보다 printf(&quot;*&quot;)를 이용한 별 찍기가 효율이 좋다!(?) 입력이 증가해도 일정한 시간이 걸린다. 가장 이상적인 성능 123void f(int n) { printf(\"Hello\");} 선형 시간 복잡도(linear time complex) f(n) = O(n) 시간은 입력의 크기(n)에 비례한다. for-loop와 while문 1234567void f(int n) { i=0; while (i &lt; n) { printf(\"hello\"); i++; }} 다항 시간 복잡도(Polynomial time complex) f(n) = O(n^k) if k=2 f(n) = O(n^2) 시간은 입력의 크기의 k제곱에 비례해서 증가한다. k=2 일때 삽입, 버블, 선택 정렬 시간복잡도 1234567void f(int n) { for (i=0; i&lt;n; i++){ //외부 loop O(n) for (j=0; j&lt;n; j++) { //내부 loop O(n) printf(\"hello\"); } }} //총 O(n^2)번 수행 지수 시간 복잡도(exponenetial time complex) f(n) = O(k^n) k=2 f(n) = O(2^n) 시간은 k의 n제곱에 비례해서 증가한다. 매우 매우 매우 좋지 않은 시간복잡도 k=2 일때 피보나치 수열, 높이가 n인 tree에서 전체 노드의 갯수 123456789/// 토끼의 수 : f(n) = f(n-1) + f(n-2)int f(int n){ if (n == 0) return 0; if (n == 1) return 1; return f(n-1) + f(n-2);} 피보나치 수열은 자기 자신을 이용해 개념을 정의한다. 따라서 Recursive(재귀적으로)로 구현한다. 입력받은 n이 0이거나 1이 아닌 경우 f(n-1) + f(n-2) 계산값을 return 한다. 입력 값이 높아질 수록 피보나치 수열을 계산하기 위해 불필요한 계산이 많아진다. n=6일 뿐인데 함수 호출 수는 25번이다. f(n)이 불리는 횟수 = 2^n 번 로그 시간 복잡도(log time complex) f(n) = O(log n) 시간은 n의 log에 비례해서 증가한다. 밑(k : base)는 생략 로그의 base에 따라 성능에 영향을 주긴 하지만 그 차이는 알고리즘 성능에서 매우 미미한 차이기 때문에 생략이 가능하다. 12345int f(int n) { for (k=1; k&lt;n; k = k*10) { printf(\"hello\"); }} k가 1,2,3…씩 증가할 때마다 코드는 1번, 10번 100번, 10000번…수행된다. 만약 입력 값이 1경정도라면 해당 코드에서 15번 loop시 수행이 끝나는 최강의 성능을 보여준다. nlogn 시간 복잡도(nlogn time complex) f(n) = O(nlogn) O(n) 보단 느리고 O(n^2)보단 빠른 성능 1234567void f(int n) { for (i=1; i&lt;n; i++) { // outer loop O(n) for (j=1; j&lt;=n; j*=10) { // inner loop O(logn) printf(\"hello\"); } }} 결론","link":"/2020/05/08/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-03-Big-O-%ED%91%9C%EA%B8%B0%EB%B2%95/"},{"title":"[자료구조] 01. 자료구조란 무엇인가?","text":"본 내용은 필자가 학부 자료구조 수업내용을 공부하기 위해 정리한 것임을 알려드립니다. 1-1. 컴퓨터란 무엇인가?컴퓨터는 ENIAC - 에니악 (전자식 숫자 적분 및 계산기)를 최초로 (ABC가 최초의 컴퓨터라는 이의로 미국 법원에서 승소, 영국이 발명한 콜로서스가 최초라는 말도 존재한다.) 30년 뒤 Apple 2 컴퓨터, 그 후로 30년 뒤 iPhone 이 발명되었으며 지금에 이르기 까지 존재했다. 그럼 다음 세대가 될 컴퓨터는 무엇일까? 우리는 3 * 4 = 12 이고 13 * 3 = 39 라는 계산 식을 암산으로 쉽게 계산이 가능하다. 하지만 세자리 수 * 세자리 수 계산은 종이에 써보면서 계산하거나 계산기를 이용하여 답을 도출해내는 것이 일반적이다. (암산으로 가능한 사람이 있을 수 있고…) 연산과 기억을 동시에 해야한다 라는 점 때문에 우리는 복잡해지는 연산을 쉽게 계산하기 어려운 것이다. Computer?계산하는 사람이라는 뜻의 단어로 요즘은 Desktop, 스마트폰 등 여러가지 전자기기에 붙는 수식어가 되었다. 앞서 말했 듯 계산은 연산과 기억을 동시에 수행해야 한다고 말했다. 계산(Computation) = 연산(calculation) + 기억 (Memory) 컴퓨터 = CPU + Memory 튜링 머신을 시작으로 좀 더 보완된 폰 노이만 구조가 요즘 컴퓨터에 까지 쓰이고 있다. 연산을 저장하는 Memory 연산을 담당하는 Processor 컴퓨터의 내부를 담당하는 Control Unit 수치, 논리계산을 담당하는 ALU 부분으로 구성되어 있다. 메모리와 프로세서가 서로 상호작용하며 연산을 수행한다. 1-2. 자료구조란 무엇인가?자료구조란 데이터를 효율적으로 관리하는 기법이다. 데이터 (Data) : 데이터를 저장하는 기본적인 단위 (int, float, char, class/struct, etc) 효율적 (Efficiency) : solution/resource solution을 내기 위해 투입 된 resource 로 나눈 것. 공간(Memory) 적게, 시간(CPU)도 적게. 관리 : 프로그램을 사용하며 많이 사용하는 연산 삽입, 검색, 제거 기법 : 구조 (데이터가 저장되어 있는 구조) + 연산 (삽입, 검색, 제거) 추상 자료형 (Abstarct data type)","link":"/2020/05/07/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-01-Introduction/"},{"title":"[자료구조] 05. Array","text":"본 내용은 필자가 학부 자료구조 수업내용을 공부하기 위해 정리한 것임을 알려드립니다. 5.1. 배열 (Array) 배열의 성질 list를 index를 이용하여 구현 연속적으로 할당 된 공간 프로그램 언어에서 기본적으로 제공 배열의 모든 원소는 index에 대응 n개의 자료를 하나의 주소로 접근 가능 배열의 첫번째 요소의 메모리 주소를 기본 주소라고 한다. arr[0] 메모리 주소에 접근하면 배열의 끝까지 접근 가능하다. 메모리에서 배열의 구현int mylist[5];를 C언어에서 선언했다고 가정하자. int mylist[5]; 선언 OS에 배열 요청 OS는 메모리에게 여유 공간이 있는 지 묻는다. Memory 승인 주소를 할당 mylist 배열은 시작주소로 23040번지를 할당했다고 가정해보자. 5개의 메모리를 선언했으므로 23040 ~ 23044번지 까지 연속된 메모리를 할당받는다. mylist 배열의 주소 == mylist[0]의 주소, n개의 자료를 하나의 주소로 접근 가능하다. 배열의 친구들 arr : 배열의 주소 size : 배열의 크기 (할당받은 메모리의 크기) count : 배열에 저장된 현재 원소의 갯수 count &lt;= size 반드시 0으로 초기화 하여 사용할 것 정적 배열 할당 12345#define SIZE 100 { int count = 0; int arr[SIZE];} 동적 배열 할당 12345#define SIZE 100{ int count = 0; int *arr = calloc(SIZE,sizeof(int)); } 배열의 연산 생성(Create) : int L[10]; 인출(Retrieve) : int x = L[5]; 저장(Store) : L[5] = x; 5.2. 배열의 검색 정렬된 배열 linear_search(A,x) binary_search(A,x) 정렬되지 않은 배열 linear_search(A,x) 검색(Search)내가 찾는 원소의 index를 return. 원소가 없으면 -1 또는 NULL return 선형 검색(Linear Search) 완전 검색, 순차 검색 첫번째 원소부터 차례로 방문 Unsorted Array 적용 가능 123456789index linear_search(Array arr, elt x){ for (int i=0; i&lt;n; i++) { if (arr[i] == x) return i; else return -1; }} 최악의 경우 : O(n) 평균의 경우 : O(n/2) 배열의 중간에서 key값을 찾은 경우 O(n) 최선의 경우 : O(1) : 바로 key값을 찾은 경우 이진 검색(Binary Search) 정렬 된 배열에서만 사용 가능 Divide &amp; Conquer(분할 정복) 알고리즘 배열 중간 원소와 key element 비교. 배열 분할 하며 검색. 배열의 중간 원소(mid)를 찾아 배열을 절반으로 Divide, 탐색을 재귀적으로 수행12345678910111213141516index binary_search(Array arr, index s, index e, elt x){ if (s==e) return (arr[s] == x) ? s : -1; //원소가 1개인 배열, start와 end가 같을 때 int mid = (s + e) / 2; if (x == arr[mid]) return mid; else if (arr[mid] &gt; x) //key는 mid보다 작기 때문에 return binary_search(arr, s, mid-1, x); //end를 mid-1로 설정 (Divide) else return binary_search(arr, mid+1, e, x); //key가 mid보다 크므로 mid+1을 start로 설정 (Divide)} recursive 구현 T(n) = T(n/2) + O(1) Recursive의 단점을 보완한 Iterative 이진 검색 구현1234567891011121314151617181920index binary_search(Array arr, elt x){ int s = 0; int e = count-1; int mid; while(s&lt;=e) { mid = (s + e) / 2; if (x == arr[mid]) //mid 값이 x값과 일치하면 리턴 return mid; else if (arr[mid] &gt; x) //mid 인덱스 값보다 x값이 작으면 e = mid - 1; // Divide else //mid 인덱스 값보다 x값이 크면 s = mid + 1; //Divide } return -1;} 최악의 경우 : O(logn) 최선의 경우 : O(1) - key값을 바로 탐색했을 때","link":"/2020/05/09/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-05-Array/"},{"title":"[자료구조] 04. List","text":"본 내용은 필자가 학부 자료구조 수업내용을 공부하기 위해 정리한 것임을 알려드립니다. 4.1. 1차원 자료구조우리는 다양한 앱을 사용한다 그런 다양한 앱을 통해 자료를 관리한다. 자세히 들여다보면 우리는 자료의 list를 관리한다. 자료의 관리는 ‘추가’, ‘검색’, ‘제거’로 이루어진다. 우리는 주소록 App에 새로 A라는 친구 번호를 ‘추가’하고, ‘제거’를 통해 B의 전화번호를 삭제한다. 하지만 사용빈도를 따져봤을 때 추가, 제거 보다는 ‘검색’ 연산을 통해 주소록에 저장 된 지인의 번호를 검색할 때가 가장 많다고 볼 수 있다. 따라서 검색이 잘 되는 자료구조가 가장 좋은 자료구조 라고 말할 수 있다. List의 정의 유한한 원소들의 나열 (a finite sequence of elements) 각 원소들은 index에 대응 된다. (index, element) 쌍 List 구현 방법 배열 (Array) : index에 기반한 구현 연결 리스트 (Linked List) : Pointer 에 기반한 구현 배열 연속된 기억공간 메모리에 배열의 크기보다 더 큰 공간이 허용되어야 한다. 연결리스트 원소 + 다음 원소의 주소 메모리에 배열의 크기보다 더 큰 연속된 공간이 없을 때 사용한다. Data + Link (다음 원소의 주소를 저장하는 Pointer) List 저장 방법검색 정렬된 list (Sorted List) (오름차순, 내림차순) 예측 가능한 원소의 위치 : 성능이 좋음 정렬되지 않은 list (Unsorted list) 원소의 위치를 예측할 수 없음 : 성능이 좋지 않음 추가 정렬된 list (Sorted List) 들어갈 원소의 자리가 정해져 있으므로, 삽입할 원소가 원소들 사이라면 기존 원소들을 뒤로 한 칸씩 밀어야 한다. 성능이 좋지 않음 정렬되지 않은 list (Unsorted list) 아무 자리에나 원소 삽입 : 성능이 좋음 삭제 정렬되었거나, 정렬되지 않은 list 모두 원소 사이의 원소를 제거하면 자리를 앞으로 땡기는 작업 수행 : 성능이 좋지 않음","link":"/2020/05/09/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-04-1%EC%B0%A8%EC%9B%90-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"title":"[프로그래머스] K번째 수","text":"배열 array를 i번째 부터 j번째 까지 자르고 정렬했을 때, k번째에 있는 수를 구한다. commands 배열의 각 행, 즉 i,j,k를 잘 뽑아내고 정렬 후 k번째 수를 answer 배열에 넣기만 하면 된다. i, j, k 명령 수행 시 k번째 수는 ‘하나’가 나오게 된다. commands의 길이는 1~50 이하 이므로 k번째 수를 담는 answer 배열의 크기는 commands.length 만큼 할당해야 한다. 그리고 i, j, k 값들을 각각 치환하여 사용하기 쉽게 만들었다. 또한 i번째 부터 j번-[ys.copyOfRange() 함수를 사용했다. 말 그대로 구간을 정해 copy하는 함수다. 첫번째 인자부터 배열의 주소(이름), 시작 인덱스, 종료 인덱스(종료 인덱스는 구간에 포함하지 않는다.) 이다. 12int[] array2 = Arrays.copyOfRange(array,i-1,j); // 배열은 0부터 시작하므로 i-1 한다. Arrays.sort() 해주고, k번째 (k-1번째 index) 수를 answer 배열에 넣고 return 해주면 된다. 123456789101112131415161718import java.util.Arrays;class Solution { public int[] solution(int[] array, int[][] commands) { int[] answer = new int[commands.length]; for (int index = 0; index&lt;commands.length; index++){ int i = commands[index][0]; int j = commands[index][1]; int k = commands[index][2]; int[] array2 = Arrays.copyOfRange(array,i-1,j); Arrays.sort(array2); answer[index] = array2[k-1]; } return answer; }}","link":"/2020/01/27/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-K%EB%B2%88%EC%A7%B8-%EC%88%98/"},{"title":"[프로그래머스] x만큼 간격이 있는 n개의 숫자","text":"문제 자체는 쉬웠지만 자칫 그냥 써버릴 수 있는 int 타입이 입력 변수 범위가 제한조건에 걸려 테스트케이스에서 실패를 했었던 문제다. 12345678910class Solution { public long[] solution(long x, int n) { long[] answer = new long[n]; for(int i=0; i&lt;n; i++){ answer[i] = x*(i+1); } return answer; }} 핵심 연산을 해주는 answer[i] = x*(i+1) 에서 반복문을 세주는 i가 int형이고 만약 x도 int형일 때 x*(i+1) 연산에서 answer[i] 값은 곱했을 때 당연히 int가 된다. (배열 선언은 long으로 해줬으면서 말이다.) 그래서 answer 배열은 n만큼 할당해줘야 하기에 solution의 변수 n을 int로 놔뒀고, 제한조건 범위 내의 연산을 위해(long 타입 연산을 위해) long 타입으로 바꿨다.","link":"/2020/02/07/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-x%EB%A7%8C%ED%81%BC-%EA%B0%84%EA%B2%A9%EC%9D%B4-%EC%9E%88%EB%8A%94-n%EA%B0%9C%EC%9D%98-%EC%88%AB%EC%9E%90/"},{"title":"[프로그래머스] 문자열을 정수로 바꾸기","text":"문자열의 길이는(s는) 1~5이고, s 맨 앞에는 부호(+,-)가 올 수 있다고 한다.부호에 따른 처리가 필요한 것인지 궁금했지만 일단 매개변수로 받은 문자열 s를 정수로 casting 해보았다. 123456789import java.util.*;class Solution { public int solution(String s) { int answer = 0; answer = Integer.parseInt(s); return answer; }} 우선 이렇게 코딩 후 실행하니 테스트케이스를 전부 통과했고, 놀랍게도 제출하니 정답으로 통과했다.하지만 남들이 푼 코드를 보니 API에 의존한 내가 너무 부끄럽게 느껴질 정도였다.남들이 푼 코드 중 하나를 가져와서 atoi에 대해 다시 한번 익혀보도록 하자. 12345678910111213141516171819public class Solution { public int solution(String str) { boolean plus = true; int value = 0; for (char ch : str.toCharArray()) { if (ch == '-') { plus = false; } else { int num = ch - 48; value = num+value*10; } } return (plus==true)? value : -1*value; }} 매개변수 문자열 str을 toCharArray로 문자로 char 변수에 받은 후 - 부호가 존재하면 plus 상태를 false라고 해주고 만약 +부호 일때는 if문을 벗어난다.문자 중 부호가 없으면 else 문으로 진입하게 되는데, 여기서부터가 atoi의 핵심이다. 12345678for (char ch : str.toCharArray()) { if (ch == '-') { plus = false; } else { int num = ch - 48; value = num+value*10; } String 객체에 담긴 문자열이 int 형 변수에 Integer로 Casting 되는 과정이다. 123456//ex) String = 12result = 0; //초기값result = (result * 10) + '1' - 48; //1result = (1 * 10) + '2' - 48; //12//result의 최종 결과 값은 12 초반에 result에 10을 곱해주는 이유는 Decimal 데이터를 얻어야 하기에 그렇다.또한 아스키코드 상에서 48은 문자열 0이므로 문자열 1(49)에서 문자열 0(48)을 빼주면 정수 1이 출력될 수 있다. 마지막으로 plus 상태가 true이면 바로 value 출력, false면 value에 -1을 곱한 후 리턴해주면 된다.","link":"/2020/02/06/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%AC%B8%EC%9E%90%EC%97%B4%EC%9D%84-%EC%A0%95%EC%88%98%EB%A1%9C-%EB%B0%94%EA%BE%B8%EA%B8%B0/"},{"title":"[프로그래머스] 문자열 다루기 기본","text":"문자열 다루기 기본 문제라는 문제 이름으로 쉬운 문제라고 생각하고 풀었다. 아스키코드 상으로 알파벳 소문자 또는 대문자가 문자열 안에 존재하면 answer 상태를 false로 바꿔주고 리턴까지 시켰다. 하지만 주어진 테스트 케이스를 통과하였지만 자꾸 테스트 5,6번에서 막혔고 이유가 뭔지 골똘히 생각하던 중에 그 이유를 찾을 수 있었다. 1문자열 s의 길이가 4 혹은 6이고, 숫자로만 구성되어 있는지 확인하는 함수, solution을 완성하세요. 아뿔싸. 문자열 s의 길이가 4또는 6인지 확인하는 구문을 넣지 않았다…해당 문제의 질문하기에는 쉬운 문제임에도 불구하고 많은 사람들이 “왜 테스트케이스 5,6번에서 막히는 거죠?” 라는 바보같은 질문을 올려댔다. 나도 그 이유를 몰라 찾아 해맸고 탄식이 나올 정도로 어이없었다. 다음부턴 입출력만 보고 문제를 푸는 습관은 고쳐야겠다 라는 당연한 생각을 했다. 1234567891011121314151617class Solution { public boolean solution(String s) { boolean answer = true; if (s.length() == 4 || s.length() == 6) { for (int i=0; i&lt;s.length(); i++){ if((65&lt;= s.charAt(i) &amp;&amp; s.charAt(i) &lt;= 90) || (97&lt;= s.charAt(i) &amp;&amp; s.charAt(i) &lt;= 122)){ answer = false; break; } } return answer; } else answer = false; return answer; }}","link":"/2020/02/07/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%8B%A4%EB%A3%A8%EA%B8%B0-%EA%B8%B0%EB%B3%B8/"},{"title":"[프로그래머스] 나머지 한 점","text":"직사각형을 만드는데 필요한 4개의 점 중 3개만 주어질 때, 주어지는 3개의 점들은 모두 각 x축 y축에 평행 하도록 하는 좌표만 주므로, 만약 [[1,4],[3,4],[3,10]] 이 주어졌을 때 중복 되는 배열의 원소 수는 소거한다. 그럼 중복 되지 않는 수가 나머지 한 점 이 된다.그러므로 [1,10] 이 output으로 나와야 한다. 주어진 2차원 배열을 비정방형 행렬로 생각하여 풀어보자. 1234 x좌표 y좌표v = [[1, 4] [0][0] [0][1] [3, 4] == [1][0] [1][1] [3,10]] [2][0] [2][1] 1234567891011121314151617181920212223242526272829class Solution { public int[] solution(int[][] v) { int x, y; // x좌표값 찾기 if (v[0][0]==v[1][0]){ x = v[2][0]; } else if (v[0][0]==v[2][0]){ x = v[1][0]; } else x = v[0][0]; //y좌표값 찾기 if(v[0][1] == v[1][1]){ y = v[2][1]; } else if(v[0][1]==v[2][1]){ y = v[1][1]; } else y = v[0][1]; int[] answer = {x,y}; return answer; }} XOR 연산자 사용하여 문제해결 12345678910111213class Solution { public int[] solution(int[][] v) { int[] answer = {0,0}; //좌표는 총 3개가 입력으로 주어지므로 반복을 3번 돌린다. for (int i=0; i&lt;3; i++){ answer[0] ^= v[i][0]; answer[1] ^= v[i][1]; } return answer; }}","link":"/2020/01/22/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%82%98%EB%A8%B8%EC%A7%80-%ED%95%9C-%EC%A0%90/"},{"title":"[프로그래머스] 서울에서 김서방 찾기","text":"서울에서 김서방 찾기… 금방 풀었다라고 생각했고 테스트 통과까지 했다.하지만 정확성 테스트에서 털려버렸고 이유는 질문하기에서 금방 찾을 수 있었다. 그것은 바로 String 비교 문제에서 항등 연산자로 문제를 풀었던 것이다. 123456789101112131415//오답 코드 (정확성 테스트 실패)class Solution { public String solution(String[] seoul) { String answer = \"\"; int i = 0; for (i=0; i&lt;seoul.length; i++){ if (seoul[i] == \"Kim\"){ //문제의 그 부분 break; } answer = \"김서방은 \"+i+\"에 있다\"; } return answer; }} 자바에서 String을 비교할 때, .equals() 는 객체끼리 내용(값)을 비교할 수 있는 메소드이고(값 자체를 비교), == 는 객체의 참조(주소)값을 비교하는 연산자이다. 무심코 생각못하고 실전에서 이런 실수를 해버렸다면 정말 끔찍했을 것이다. 1234567891011121314//솔루션class Solution { public String solution(String[] seoul) { String answer = \"\"; String kim = \"Kim\"; int i = 0; for (i=0; i&lt;seoul.length; i++){ if (seoul[i].equals(kim)){ answer = \"김서방은 \"+i+\"에 있다\"; //띄어쓰기 주의 } } return answer; }}","link":"/2020/01/26/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%84%9C%EC%9A%B8%EC%97%90%EC%84%9C-%EA%B9%80%EC%84%9C%EB%B0%A9-%EC%B0%BE%EA%B8%B0/"},{"title":"[프로그래머스] 수박수박수박수박수박수?","text":"입력 n이 1일 땐 “수” 출력, n이 2이면 “수박”, 3이면 “수박수” … index 초기값을 1로 초기화 하고 반복문을 통해 i가 증가 할때마다 홀수, 짝수 판별을 한다. 만약 홀수면 “수”, 짝수면 “박”을 answer 에 추가해가면서 n번 반복한다. 12345678910111213class Solution { public String solution(int n) { String answer = \"\"; for (int i = 1; i &lt;= n; i++){ if (i % 2 == 1) { answer += \"수\"; } else { answer += \"박\"; } } return answer; }}","link":"/2020/02/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%88%98%EB%B0%95%EC%88%98%EB%B0%95%EC%88%98%EB%B0%95%EC%88%98%EB%B0%95%EC%88%98%EB%B0%95%EC%88%98/"},{"title":"[프로그래머스] 순열 검사","text":"배열의 크기가 4면 1부터 4까지 무조건 중복없이 숫자가 들어간다. arr = [4,2,3,1] 하지만 원소의 순서는 뒤죽박죽이 되어 있을 수 있다. 그러므로 java.util.Arrays를 import 하고 매개변수로 들어오는 arr 배열을 sort 시켜준다. 그리고 arr의 index와 index 내부의 원소가 같은 지 판별하는 알고리즘을 짜도록 한다. 12345678910111213141516import java.util.Arrays;class Solution { public boolean solution(int[] arr) { boolean answer = true; Arrays.sort(arr); for (int i=0; i&lt;arr.length; i++){ //배열의 첫번째 방(0번째 방)에 원소 1이 있는지부터 판별 if(arr[i]!=i+1) { answer = false; break; } } return answer; }}","link":"/2020/01/22/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%88%9C%EC%97%B4-%EA%B2%80%EC%82%AC/"},{"title":"[프로그래머스] 자릿 수 더하기","text":"컴퓨터과학 수업에서 새로운 언어를 배울 때 지겹도록 짜본 코드…하지만 간과하지 말자. 이런 간단한 것도 생각이 안날 수 있으니까. 123456789101112import java.util.*;public class Solution { public int solution(int n) { int answer = 0; while (n!=0) { answer += n % 10; n /= 10; } return answer; }}","link":"/2020/01/22/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%9E%90%EB%A6%BF-%EC%88%98-%EB%8D%94%ED%95%98%EA%B8%B0/"},{"title":"[프로그래머스] 시저 암호","text":"아스키를 잘 다룬다면 쉬운 문제겠지만 잘 못다룬다면 어려운 문제일 수 있겠다. 문자열과 정수를 입력받아 정수 만큼 다음 문자로 밀어주는 (예를 들면 A가 2만큼 이동하면 C) 카이사르 암호 문제이다. 이 문제에서 잘 생각해야 하는 부분은 알파벳에서 소문자 대문자를 포함하지 않는다면 A 부터 Z까지 모두 26자 이다. 여기서 Z에서 정수 1을 받게 되면 A로 다시 돌아와야 한다. 그렇기 때문에 입력 받은 n을 밀어낼 자리 수 계산을 위해 n = n % 26 을 이용. 26(Z)이 넘어가게 되면 나머지 값 1 , 즉 A 부터 다시 출력 할 수 있게 한다. 문자열 s의 길이 만큼 반복하고, char 변수에 문자열에서 문자 하나를 받아 소문자, 대문자를 판별한다. 사용한 라이브러리 함수는 isLowerCase(), isUpperCase() 이다. boolean 타입이며 각각 소문자면 해당 문자가 소문자, 대문자면 true, false를 내보낸다. 그 후 이동시킬 알파벳 ch에서 ‘A’ 또는 ‘a’를 빼고 밀어줄 n값을 더한 후 전체 알파벳 수(26)로 나눈 나머지를 구하면 이동할 거리가 완벽하게 계산된다. 그걸 다시 초기값 ‘A’ 또는 ‘a’에 더해주면 ch 문자로부터 n만큼 이동한 알파벳이 나오게 된다. 마지막으로 입력 받았을 때 공백이 포함 된 문자열이 있으므로 공백 (ascii 값 32) 처리로 마무리 한다. ascii를 계산하는 핵심 공식을 잘 알아둬야겠다. 1234567891011121314151617181920class Solution { public String solution(String s, int n) { String answer = \"\"; n = n % 26; for (int i=0; i&lt;s.length(); i++){ char ch = s.charAt(i); if (Character.isLowerCase(ch)) { //소문자면 ch = (char)((ch-'a'+n) % 26 + 'a'); //핵심 공식 } else if (Character.isUpperCase(ch)) { //대문자면 ch = (char)((ch-'A'+n) % 26 + 'A'); //핵심 공식 } else if (ch == 32) { //받은 문자가 공백일 때 answer += \"\"; } answer = answer + ch; } return answer; }}","link":"/2020/02/25/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%8B%9C%EC%A0%80-%EC%95%94%ED%98%B8/"},{"title":"[프로그래머스] 직사각형 별 찍기","text":"이중 for문을 잘 이해하라! 12345678910111213141516import java.util.Scanner;public class Solution { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a = sc.nextInt(); int b = sc.nextInt(); for (int i=0; i&lt;b; i++){ for (int j=0; j&lt;a; j++){ System.out.print(\"*\"); } System.out.println(); } }}","link":"/2020/01/26/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%A7%81%EC%82%AC%EA%B0%81%ED%98%95-%EB%B3%84-%EC%B0%8D%EA%B8%B0/"},{"title":"[프로그래머스] 짝수와 홀수","text":"num이 짝수면 Even 홀수면 Odd 123456789101112class Solution { public String solution(int num) { String answer = \"\"; if (num % 2 == 0){ answer = \"Even\"; } else{ answer = \"Odd\"; } return answer; }}","link":"/2020/01/26/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%A7%9D%EC%88%98%EC%99%80-%ED%99%80%EC%88%98/"},{"title":"[HTML&#x2F;CSS] 02. HTML 태그","text":"본 내용은 필자가 부스트코스 웹UI 개발 코스를 수강 후 공부하기 위해 정리한 것임을 알려드립니다. HTML 태그Heading 태그(제목 태그) 문서 내의 제목을 표현할 때 사용. &lt;h&gt;로 시작. h1 ~ h6까지 존재한다. 숫자가 낮을수록 더 큰 제목으로 사용한다. 숫자가 올라갈수록 더 낮은 수준의 소제목으로 사용됨. 단락 태그 Paragraph 태그로 줄여서 &lt;p&gt;라고 쓴다. 쓰는 경우 자연스럽게 개행이 가능. 글의 단락을 나타냄. 개행 태그 Linebreak, 줄여서 &lt;br&gt; 태그라고 한다. 글의 개행을 나타냄. &lt;p&gt;태그에서 강제로 개행을 해주려면 &lt;br&gt;태그를 사용해야만 함. 텍스트 관련 태그&lt;b&gt; 태그 볼드 태그로 글자를 굵게 표현 &lt;i&gt; 태그 글자를 이탤릭체로 표현 &lt;u&gt; 태그 글자의 언더라인(밑줄)을 그려줌. &lt;s&gt; 태그 글자에 중간선을 표현한다. 앵커 태그 링크를 생성하는 태그 HTML에 가장 큰 특징이 되는 태그 &lt;a&gt; 태그로 명시 링크를 만들기 위한 하나의 속성을 필수로 가져야 한다. href 속성 하이퍼 레퍼런스라고 불림. 링크의 목적지인 url이 들어간다.1&lt;a href=&quot;https://www.naver.com&quot;&gt;네이버&lt;/a&gt; target 속성 링크된 리소스를 어디에 표시할지 나타내는 속성이다. 속성 값으로는 -self, _blank, _top이 있다. _self는 현재 화면에 표시한다는 의미. 타겟 속성의 default값이기도 하다. _blank는 새로운 창에 외부 페이지가 나타나게 하는 속성이다. 새로운 탭에 url 열기와 같은 기능. 내부 링크 &lt;a&gt;를 통해 페이지 내부의 특정 요소로 초점을 이동할 때 사용하는 태그. 속성 값에 #를 쓰고 페이지에서 이동하고자 하는 요소 id값을 넣으면 된다.1&lt;a href=&quot;#some-element-id&quot;&gt;자기소개 페이지로 이동&lt;/a&gt; 의미가 없는 태그 요소 단순하게 요소들을 묶기 위한 태그 스타일을 주거나, 서버에서 보내는 데이터를 담기위한 용도로 사용. 의미는 없지만 사용빈도는 엄청 높다. division 요소 &lt;div&gt; 블록 레벨 태그 span 요소 &lt;span&gt; 인라인 레벨 태그 리스트 요소 태그&lt;ul&gt; 태그 ul : unordered list, 순서가 없는 리스트를 표현12345&lt;ul&gt; &lt;li&gt;아이언맨&lt;/li&gt; &lt;li&gt;캡틴 아메리카&lt;/li&gt; &lt;li&gt;토르 오딘슨&lt;/li&gt;&lt;/ul&gt; 각 항목을 나타내는 태그는 &lt;li&gt; 태그로 나타낸다. &lt;ol&gt; 태그 ol : ordered list, 순서가 있는 리스트 표현.12345&lt;ol&gt; &lt;li&gt;아이언맨1&lt;/li&gt; &lt;li&gt;캡틴 아메리카: 퍼스트 어벤져&lt;/li&gt; &lt;li&gt;토르 천둥의 신&lt;/li&gt;&lt;/ol&gt; &lt;dl&gt; 태그 &lt;dl&gt;(definition/description list) 태그로 용어 설명 리스트 구현. 용어와 그에 대한 정의를 표현. &lt;dt, &lt;dd&gt; 태그를 이용하여 항목을 나타냄 &lt;dt&gt; : 용어 &lt;dd&gt; : 용어에 대한 설명 이미지 요소 태그1&lt;img src=&quot;./images/pizza.png&quot; alt=&quot;피자&quot;&gt; 이미지 경로를 알려주기 위한 src 필수 속성. 이미지의 대체 텍스트를 입력하기 위한 alt 속성. 웹 접근성을 위해 필요한 필수 속성 중 하나. (스크린 리더기) width/height 속성 : optional한 속성. 이미지의 크기가 고정적이라면 너비, 높이 속성을 써주는 것이 성능적인 측면에서 좋다. src 속성 상대경로 : 현재 웹 문서의 페이지를 기준으로 상대적으로 이미지의 위치를 나타낸다. 같은 이미지를 삽입하더라도 불러오는 이미지의 위치에 따라 이미지가 달라질 수 있다. 절대경로 : 실제 그 이미지가 위치해있는 곳의 전체 경로. 어느 페이지에서 불러오더라도 항상 같은 주소를 가지게 된다. gif : 256색으로 제한적이지만 용량이 작고, 애니메이션과 투명 이미지가 가능 jpg : 높은 압축률과 자연스러운 색상 표현 가능 png : 이미지 손실이 적으며 투명과 반투명을 모두 지원하는 형식 테이블 태그 표는 셀로 이루어져 있다. 표의 행(row)과 열(column) 테이블 요소를 표현하는 방법은, 먼저 &lt;table&gt; 태그로 감싸준 후 시작한다. 테이블 구성 시, 위에서 밑으로, 왼쪽에서 오른쪽으로 그려준다고 생각하고 작성한다. &lt;table&gt; : 표를 나타내는 태그. &lt;table&gt;은 하나 이상의 &lt;tr&gt;로 이루어져 있다. &lt;tr&gt; : table-row를 나타내는 태그 (행). &lt;tr&gt;은 하나 이상의 &lt;th&gt;, &lt;td&gt;로 이루어져 있다. &lt;th&gt; : 제목 셀을 나타내는 태그 &lt;td&gt; : 셀을 나타내는 태그 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Table&lt;/title&gt; &lt;style&gt; &lt;!--th와 td 태그에 테두리 그리기--&gt; th,td {border: 1px solid;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;4&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;5&lt;/td&gt; &lt;td&gt;6&lt;/td&gt; &lt;td&gt;7&lt;/td&gt; &lt;td&gt;8&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;9&lt;/td&gt; &lt;td&gt;10&lt;/td&gt; &lt;td&gt;11&lt;/td&gt; &lt;td&gt;12&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt;","link":"/2021/01/08/HTML-CSS-02-HTML-%ED%83%9C%EA%B7%B8/"},{"title":"[안드로이드] 뷰의 속성","text":"뷰 (View) 뷰는 안드로이드 기본 화면을 구성하는 모든 기본 화면 구성요소 눈에 보이는 것을 Widget, 눈에 보이지 않는 것을 Layout이라고 구분한다. 레이아웃은 그 안에 다른 뷰를 담을 수 있다. 그런데 레이아웃도 뷰를 상속하기 때문에 레이아웃 안에 레이아웃을 담을 수 있다. 뷰의 크기 속성 화면을 구성하는 xml 파일 안에 태그와 속성이 들어간다. 해당 xml 파일을 시스템이 읽어 앱의 화면으로 보여지게 된다. 123456&lt;시작태그 속성1 = &quot;값1&quot; 속성2 = &quot;값2&quot;&lt;/끝태그&gt; 1234&lt;TextView android:layout_width = &quot;wrap_content&quot; android:layout_height = &quot;wrap_content&quot; android:text = &quot;Hello World!&quot; /&gt; 태그가 추가된 레이아웃의 구성 뷰는 가로 세로 크기가 필수 속성이다. 따라서 layout_width, layout_height 속성을 반드시 넣어줘야 한다. 크기를 지정하는 방법은 세가지가 존재 상위 뷰 크기에 맞게 구성요소를 확장하는 match_parent 속성 ViewGroup에 남아있는 여유 공간을 채움 뷰 안에 들어있는 내용물의 크기에 딱 맞게 크기를 결정하는 wrap_content 속성 원하는 크기(dp 또는 px 단위)를 숫자로 지정하는 방법 ConstraintLayout(제약 레이아웃)은 match_parent를 지원하지 않음 LinearLayout(리니어 레이아웃)은 시작태그에 android:orientation 값으로 vertical 또는 horizontal 속성을 꼭 가져야 함","link":"/2021/02/17/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EB%B7%B0%EC%9D%98-%EC%86%8D%EC%84%B1/"},{"title":"[안드로이드] 제약 레이아웃(Constraint Layout)","text":"제약 레이아웃(ConstraintLayout) 제약 레이아웃은 처음 프로젝트를 만들었을 때 자동으로 만들어지는 레이아웃이다. 제약 레이아웃은 제약 조건을 이용해 그 안에 추가된 뷰들의 위치를 결정한다. 제약 조건은 연결선을 통해서 만들어진다. 연결선(핸들 Handle)은 뷰의 상,하,좌,우에 있는 연결점(앵커 포인트)을 다른 레이아웃이나 위젯의 상,하,좌,우와 연결하여 만들 수 있다. 연결해서 만들어지는 연결선이 Constraint(제약조건)가 된다. iOS 앱개발 시 사용하는 레이아웃 방식과 유사하다. 위 모습 상자에 상하좌우 0이라고 적혀있는 것은 Margin 정도로, 벽면(부모 View)에서 떨어진 정도를 나타내는 수치이다. 아래 Constraint가 제약 조건인데, 부모 View로부터 상하좌우 떨어진 정도를 나타낸다. (단위는 dp) 제약 레이아웃 내부에 View 생성 연결선을 사용하여 View를 만들어준다. 같은 레이아웃 내부에 두개의 View margin 값을 포함하여 같은 뷰 그룹안에 포함된 뷰끼리도 연결하여 위치 지정이 가능 Bias View가 상하로 제약되어 있거나, 좌우로 제약되어 있으면 View는 정 가운데로 오게 된다. 마찬가지로 상하좌우 모두 제약 되어 있을 때도 마찬가지. 이렇게 모두 ‘제약’되어 있을 때 View가 어디든 위치할 수 있도록 해주는 수치 값을 Bias라고 한다. Guideline 레이아웃 이외에 가이드라인을 가로/세로(vertical/horizontal) 정해서 다른 뷰끼리 서로 정렬시켜주는 역할을 하는 기능 xml을 열고 Design 탭 - 화면 상단 Guidelines 버튼을 눌러 사용. 결론이렇게 제약 레이아웃에서 View의 위치(Widget)를 결정할 때는 연결선이 중요한 역할을 한다.","link":"/2021/02/17/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%A0%9C%EC%95%BD-%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83-Constraint-Layout/"},{"title":"[안드로이드] 대표적인 레이아웃","text":"대표적인 레이아웃 리니어 레이아웃(LinearLayout) 뷰를 아래쪽으로만 추가(vertical) 하는 방법 뷰를 오른쪽으로만 추가(horizontal) 하는 방법 레이아웃도 마찬가지로 view 개념이기 때문에 리니어 레이아웃 내부에 또다른 리니어 레이아웃을 추가하여 각각 서로 다른 orientation 속성을 추가. 복잡한 View 구성을 가능하게 한다. layout_gravity 속성 View 자체를 정렬하는 속성 리니어 레이아웃에서 각각의 뷰들은 자신들만의 공간을 갖게 되는 형태를 띈다. orientation이 vertical일때, 각 뷰는 horizontal 방향으로 자신 만의 공간을 갖게 됨. 따라서 layout_gravity 값을 center_horizontal로 뷰를 중앙 정렬할 수 있음. orientation이 horizontal일 때, 각 뷰는 vertical 방향으로 자신 만의 공간을 갖게 된다. 따라서 layout_gravity 값을 center_vertical로 뷰를 중앙 정렬할 수 있음 이 외에도 다른 값들로 뷰를 중앙 정렬하는 방법이 존재한다. gravity 속성 View 안에 들어있는 Text, 내용물을 정렬해주는 속성 layout_margin 속성 View 상하좌우 바깥쪽에 다른 뷰 또는 부모 뷰와 여유 공간을 만드는 속성 layout_margin은 상하좌우 모두 같은 값(dp)을 주어 여유공간을 만듬. layout_marginBottom : View 바깥 아래쪽에만 여유공간을 준다. layout_marginStart, Left, Top, End, Right 등 속성 padding 속성 View 내부 내용물과 View 경계 사이의 여유공간을 주는 속성 padding 값은 View 경계와 내용물 사이의 공간을 상하좌우 모두 주는 속성 margin과 마찬가지로 각각에 대해 padding을 설정해줄 수 있음 paddingStart, Left, Top, End, Right 등 속성 layout_weight 속성 남아있는 공간을 분할하는 역할 두개의 View가 있을 때, 만약 가로 방향(horizontal)으로 남아있는 공간을 할당하려면? 가로 방향이기 때문에 layout_width 값은 0dp로 주고, layout_weight값을 각각 1로 준다. 그럼 공간을 각각 반반씩 나누어 가지게 된다. 다른 방법으로, 각각 2/3, 1/3 공간을 갖게 하려면? 똑같이 width 값은 모두 0dp에, weight값을 각각 2, 1로 주게 되면 한 View의 weight 값/동일 공간 View들의 weight 합 비율로 공간이 할당된다. 2/3, 1/3 공간 할당 button2 weight = 3 / 동일 공간 View들의 weight 합 4 =&gt; 3/4 공간 할당 button3 weight = 1 / 동일 공간 View들의 weight 합 4 =&gt; 1/4 공간 할당 상대 레이아웃(RelativeLayout) 상대 레이아웃은 뷰를 담고 있는 부모 레이아웃이나 그 안에 들어있는 다른 뷰들과의 상대적 위치를 이용해 화면을 배치하는 레이아웃이다. ConstraintLayout과 상당히 유사 제약 레이아웃이 최근에 나온 레이아웃이고 기능이 훨씬 많음. 따라서 상대 레이아웃은 많이 쓰지 않는 추세 뷰 또는 위젯과 부모 레이아웃 간의 관계를 사용할 수 있음 -&gt; layout_align 속성 하나의 뷰가 있으면 다른 뷰하고의 관계를 사용할 수 있음 -&gt; layout_toXXXXOf / layout_alignXXXX 속성 layout_align 속성 부모 레이아웃 간의 상대적 위치를 지정할 때 사용하는 속성1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;169dp&quot; android:layout_height=&quot;127dp&quot; android:layout_alignParentTop=&quot;true&quot; android:layout_alignParentRight=&quot;true&quot; android:text=&quot;Button1&quot; /&gt;&lt;/RelativeLayout&gt; Button의 layout_alignParentTop과 layout_alignParentRight 속성 모두 true값으로 지정한다면 그때의 부모 레이아웃의 위쪽과 오른쪽에 붙게 된다. 상대 레이아웃은 위에 아무 View 배치 없이 Button을 그냥 화면 아래쪽에 두고 싶다면 간단히 layout_alignParentBottom 속성을 true로 만들어주면 된다. LinearLayout은 이런 배치가 힘들다. layout_toXXXXOf / layout_alignXXXX 속성 다른 View간의 상대적 위치를 지정할 때 사용하는 속성 레이아웃의 상대적 위치를 설정하는 속성엔 Parent가 붙지만, View와의 상대적 위치를 지정하는 속성엔 붙지 않는다는 차이가 있다. layout_toLeftOf, layout_toRightOf, layout_alignTop, layout_alignBottom 등 프레임 레이아웃(FrameLayout) 한 번에 하나의 뷰만 보여주는데, 여러 개를 추가했을 경우 다른 뷰들이 중첩되어 깔려있는 형태로 보여진다. 다른 뷰들을 감춰놓았다가 필요할 때마다 보여주고 제일 앞에 있는 뷰를 감추는 방식 결국은 이런 동작들이 화면을 전환하는 것처럼 보여지게 된다. 테이블 레이아웃(TableLayout) 격자(Grid) 형태로 뷰를 보여주는 레이아웃 View의 영역 뷰의 테두리(Border)를 기준으로 바깥쪽이 Margin, 안쪽이 Padding 뷰의 영역은 margin까지를 포함함 View의 배경색 background 속성으로 배경색을 설정 배경 이미지 설정도 가능 ARGB를 기준으로 16진수 두자리씩 할당하며 #뒤에 코드를 붙인다 A는 알파값으로 투명도를 나타낸다.","link":"/2021/02/19/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EB%8C%80%ED%91%9C%EC%A0%81%EC%9D%B8-%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83/"},{"title":"[Elasticsearch] GCP VM 환경세팅","text":"본 포스트는 상명대학교 Elasticsearch 엔지니어 트레이닝 과정을 이수하고 작성한 글입니다. 개인이 간단하게 실습을 위해 작성한 포스트이며 Enterprise 급 운용을 위한 글이 아님을 밝힙니다. Google Cloud Platform VM 환경 세팅 해당 글은 학교에서 진행하는 Elasticsearch Engineer Training 과정을 위한 환경설정을 간략 기술해놓은 포스트임. 환경 설정 또한 용도에 따라 다를 수 있으니 참고 https://cloud.google.com/gcp Get Started for free를 클릭하여 무료로 사용 초반 무료 계정은 300불의 무료 크레딧으로 사용 가능하다. 약관 동의, 이름, 주소, 카드 정보 입력 진행 GCP 메인 화면 진입 Compute Engine - VM 인스턴스 메뉴 선택 1분 정도 대기 한 후 만들기 버튼 선택 새 VM 인스턴스 만들기 인스턴스 이름은 자유롭게 서울 리전(asia-northeast2) 선택 머신 유형은 e2-standard-8(vCPU 8개, 32GB 메모리) 디스크 사이즈 변경, 액세스 범위 설정 및 방화벽 설정 부팅 디스크 Debian GNU/Linux 10 (buster) 선택 10GB(default)에서 30GB로 디스크 사이즈 변경 액세스 범위 : 모든 Cloud API에 대한 전체 액세스 허용 방화벽 : HTTP/HTTPS 트래픽 허용에 모두 체크 VM 환경 세팅 완료","link":"/2021/02/20/Elasticsearch-GCP-VM-%ED%99%98%EA%B2%BD%EC%84%B8%ED%8C%85/"},{"title":"[Elasticsearch] Elasticsearch Engineer Training -2","text":"본 포스트는 상명대학교 Elasticsearch 엔지니어 트레이닝 과정을 이수하고 작성한 글입니다. 개인이 간단하게 실습을 위해 작성한 포스트이며 Enterprise 급 운용을 위한 글이 아님을 밝힙니다. 복습 Elasticsearch는 텍스트, 숫자, 위치 기반 정보, 정형 및 비정형 데이터 등 모든 유형의 데이터를 위한 무료 검색 및 분석 엔진으로 분산형 및 개방형을 특징으로 한다. Elasticsearch는 Apache Lucnene을 기반으로 구축 되었으며 2010년에 현 Elastic으로 출시되었다. Elasticsearch의 사용 애플리케이션 검색 웹사이트 검색 엔터프라이즈 검색 로깅과 로그 분석 인프라 메트릭과 컨테이너 모니터링 애플리케이션 성능 모니터링 위치 기반 정보 데이터 분석 및 시각화 보안 분석 비즈니스 분석 Elasticsearch의 동작 로그, 시스템 메트릭, 웹 애플리케이션 등의 소스로부터 원시 데이터가 Elasticsearch로 들어간다. 이러한 데이터 수집은 원시 데이터가 Elasticsearch에서 indexing되기 전에 구문 분석, 정규화, 강화 되는 프로세스이다. indexing 후 데이터에 대해 사용자는 복잡한 쿼리를 실행하고 집계를 사용하여 복잡한 요약을 검색할 수 있다. Kibana에서 데이터를 강력하게 시각화하고 대시보드 공유, Elastic Stack을 관리할 수 있다. Kibana는 elasticsearch의 클라이언트 역할을 한다. Kibana의 사용 Kibana는 Elasticsearch를 위한 시각화 및 관리 도구 실시간 히스토그램, 선 그래프, 파이 차트, 지도 등을 제공 사용자가 자신의 데이터를 기반으로 사용자 정의한 동적 인포그래픽을 만들 수 있다. (Canvas) 위치 기반 정보 데이터 시각화 (Elastic Maps) Elasticsearch의 index 개념 Elasticsearch index는 서로 관련된 문서들의 모음이다. JSON 문서로 데이터를 저장 각 문서는 일련의 키와 그에 해당하는 값을 서로 연결 Elasticsearch가 문서 저장, 역 인덱스를 구축하여 거의 실시간으로 문서를 검색할 수 있게 한다. Day02_ Logstash, Beats 실습환경 세팅 elasticsearch.yml 편집 network.host : [_site_, _local_] 로 수정 vim 에디터로 아래 파일을 열어 가장 아랫줄에 두 line 핸들링 (root 권한 필요) 1234sudo vi /etc/sysctl.confvm.max_map_count=262164vm.swappiness=1 1234sudo vi /etc/security/limits.conf[user_id] soft memlock unlimited[user_id] hardmemlock unlimited 콘솔 상에 명령어 실행 1sudo shutdown -r now 터미널 전부 종료 elasticsearch 및 Kibana 재 실행 가공데이터가 저장된 웹서버 접속해놓기 (Ted님 개인 웹서버) elasticsearch에 암호가 걸려있을 때 IP, ID, Password를 통해 접속하는 명령 1curl -XGET http://외부IP:포트번호 -u elastic:비밀번호 Logstash 설치 12curl -L -O https://artifacts.elastic.co/downloads/logstash/logstash-7.11.1-linux-x86_64.tar.gz Beats 소개Elastic에서 제공하는 Beat 솔루션들 FileBeat PacketBeat WinlogBeat MetricBeat HeartBeat AuditBeat FunctionBeat JournalBeat FileBeat 설치 1curl -L -O https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-7.11.1-linux-x86_64.tar.gz Logstash, FileBeat 압축해제 12tar -xzvf logstash-7.11.1-linux-x86_64.tar.gztar -xzvf filebeat-7.11.1-linux-x86_64.tar.gz 다운로드 받았던 설치파일 관리 1mv *.gz ./stack 디렉토리 이름 변경 12mv logstash-7.11.1/ ls-711mv filebeat-7.11.1-linux-x86_64/ fb-711 Logstash의 특징 logstash는 3가지 섹터로 이루어지는데, 이것을 통틀어 Pipeline 이라고 한다. 입력 및 출력은 별도의 필터를 사용하지 않고도 파이프라인에 들어가거나 나올 때 데이터를 인코딩하거나 디코딩 할 수 있는 코덱을 지원한다. Input 섹션에서 데이터를 받아들인다. 데이터를 받아들여 이벤트를 생성 stdin : 표준 입력 file(DB, csv) beats : beats에서 보낸 이벤트 처리 etc Filter 섹션에서 데이터 연산 입력 섹션에서 들어온 이벤트를 수정 EOF가 될 때까지 데이터를 읽음 중간에 프로세스가 종료될 수 있기 때문에 offset으로 읽었던 지점 저장 읽어들이는 event들은 각각 6개의 파티션으로 구분됨 각 파티션은 commma seperated되어 구분됨 JSON 파일 형태로 객체화하여 elasticsearch로 던져준다. JSON 파일도 용도에 따라 자료구조가 다르다 (검색 용도, 분석 용도) 필터 플러그인 mutate : 이벤트 필드에 대한 일반적인 변화 수행 Output 섹션으로 출력 정제된 이벤트 데이터가 들어가는 섹션 출력 타겟은 multi로 들어갈 수 있음 이벤트 데이터들을 표준 출력(stdout)과 elasticsearch 등으로 보내기가 가능 사용자 IP의 송신, 수신 데이터를 받아들일 수 있는 모듈 파일 Logstash 파이프라인으로 이벤트를 받아 ES에 출력표준 입력으로 데이터 받기 실습 Logstash 폴더 안에 사용자 정의 파이프라인 configuration을 담기위해 만들고 싶은 디렉토리를 만든다. 1mkdir 디렉토리 명 사용자 정의 파이프라인 configuration 파일을 만들어 vim 에디터로 아래 코드 작성을 한다. 1vi 파일명.conf 아직 Filter 섹션은 정의하지 않은 상태 필터 섹션은 선택 사항이다. input, output 방식 설정 후 host의 elasticsearch로 데이터 전송하고자 함 입력은 콘솔에 입력하는 표준입력 방식을 사용 다 작성했다면 logstash 폴더로 이동 파이프라인 동작 1./bin/logstash -f ./디렉토리명/파일명.conf 1&gt;&gt;&gt; 콘솔에 직접 메시지 입력 123456{ &quot;message&quot; =&gt; &quot;입력한 내용&quot;, &quot;host&quot; =&gt; &quot;Host 이름&quot;, &quot;@timestamp&quot; =&gt; 2021-02-23T02:52:04.037Z, &quot;@version&quot; =&gt; &quot;1&quot;} 결과 위와 같은 형태 (JSON) 형태로 입력한 메시지가 conf파일의 output(hosts, user, password)정보를 가진 elasticsearch에 전송된 것을 볼 수 있었던 실습이었음. File 형태로 이벤트 데이터 파이프라이닝 실습 Ted님의 웹서버에서 blogs.csv 파일을 vm에 다운로드 받았다. cat으로 csv 파일을 까본 결과… 어마어마한 문서 양으로 도중에 멈췄다. 그런데 중간에 세미콜론으로 의미가 구분되어 있는 것이 보인다. 아까 만든 디렉토리에 또다른 conf 파일을 생성하여 이번엔 새로운 파이프라인을 구축한다. 1vi 파일명.conf 코드 작성 오타가 나지 않도록 주의하자 코드 분석 input 섹션 file : file로 받겠다는 의미. csv 파일 path : 파일을 읽어올 경로 start_position : Logstash를 시작 할 때 file의 어디서부터 읽을 것인지 결정하는 설정. start_positon 값이 beginning인 경우 재 시작하더라도 파일의 처음부터 읽겠다고 명시 since_db_path logstash에서 최초 실행 이후 재실행 시, 마지막으로 읽은 파일위치를 since_db에 저장된 offset부터 읽기 시작한다. 따라서 since_db_path는 파일을 마지막으로 읽은 위치를 가져오기 위한 경로를 설정하는 것인데, 위 start_position의 값을 beginning으로 해놓았기 때문에 의미가 없다고 봐야한다. (읽을 때마다 처음부터 다시 읽기 때문에) 그래서 값인 /dev/null은 경로 없음이나 다름없다고 생각해도 된다. 테스트 환경인 경우 since_db 경로 때문에 테스트가 번거롭다고 한다. filter 섹션 dissect 필터 : 추출할 필드의 시퀀스와 필드 사이의 구분 문자 지정 이벤트 데이터 전체에 반영된 공통 구조를 그대로 이용하여 원하는 부분을 잘라내는 기능을 한다. mapping message : 이벤트 데이터를 세미콜론 구분자로 형식을 설정하고 나눈 데이터의 이름을 지정한다. date 필터 : 날짜를 구문 분석 후 해당 날짜 또는 타임 스탬프를 이벤트의 logstash 타임 스탬프로 사용하는데 사용 이벤트 데이터의 날짜는 elasticsearch가 이해하도록 변환하는 작업을 거쳐야 한다. 그렇지 않으면 String Type으로 인식하여 날짜 관련 visulization을 진행하지 못할 수 있다. match : value type은 array. dissect 필터에서 가공된 date field를 다음과 같은 format으로 변환 target : match에 지정된 형식으로 target된 필드에 타임 스탬프 저장 remove_field : date 필터 기능이 수행되면 이벤트 데이터에서 해당 필드를 제거 mutate 필터 : 이벤트 데이터에서 필드의 이름에 대한 연산 수행 (수정, 삭제) remove_field : mutate 필터링이 성공했을 때 해당 필드를 제거 필터링 되기 전 필드들은 지워지지 않고 미러링되어 디스크에 쌓이게 된다. 사용하고자 하는 필드가 없다면 꼭 remove_field로 바뀌기 전 필드들을 삭제하라 output 섹션 stdout : 표준출력, 콘솔에 출력 시 json 형태로 출력한다. elasticsearch : 사용자의 elasticsearch에 이벤트 데이터 출력 index : elasticsearch에 전송되어 쿼리될 인덱스 이름 지정 host, user, password : elasticsearch의 주소와 암호 파이프라인 실행 1./bin/logstash -f ./디렉토리명/파일명.conf 전송 결과 확인 elasticsearch client로 접속 Menu -&gt; Management - Dev Tools 1GET blogs/_search 해당 메소드로 쿼리하여 json 포맷 결과 확인 Elasticsearch REST Query 위 blogs.csv 파이프라이닝 실습과 이어짐 Console에 아래 명령 입력 123456789101112131415GET _cat/indices?v&amp;s=index:desc //인덱스 정보 출력//method [index_name]/_QUERY 형태GET [index_name]/_count//좀 더 정확한 검색GET [index_name]/_search{ &quot;query&quot;: { //항상 query 속성이 먼저 오게 됨. &quot;match&quot;: { &quot;seo_title&quot;: &quot;logstash&quot; } }} 인덱스 이름이 blog인 데이터 중에서 seo_title에 logstash가 있거나 released라는 단어가 있는 데이터를 찾는 쿼리 (기본적으로 OR Condition) hits를 봤을 때 총 113건의 데이터가 나온 것을 볼 수 있다. 12345678910111213GET blogs/_search{ &quot;_source&quot;: &quot;title&quot;, &quot;size&quot;: 100, &quot;query&quot;: { &quot;match&quot;: { &quot;seo_title&quot;: { &quot;query&quot;: &quot;elasticsearch released&quot;, &quot;operator&quot;: &quot;and&quot; } } }} seo_title 필드에 elsasticsearch와 released 단어가 모두 있으며, size가 100인 title을 조회하라 Filebeat 실습 filebeat의 module 폴더를 확인하면, 여러 product들의 log format을 볼 수 있다. 아직 잘 모르겠지만 프로덕트마다 로그 포맷이 달라 엄청난 기능이라고 하셨다. 간단하게 Filebeat에 enable만 하면 사용할 수 있게 되어 있음. 1. 샘플 데이터 다운로드 및 환경 설정 따로 설정한 filebeat.yml 파일, 로그 데이터 압축 파일을 Ted님의 웹서버에서 받아 로컬 환경에 맞게 세팅 홈디렉토리에 sample-data 폴더 생성 다운받은 로그 샘플 데이터 압축 해제 …server1, server2, server3 폴더들 많은 양의 로그 파일들을 볼 수 있다 filebeat.inputs의 paths : 로그 샘플 데이터가 있는 디렉토리 경로 설정 output.elasticsearch : 로그를 뿌려줄 elasticsearch 호스트와 암호 설정 여기서 index 형태도 설정할 수 있다. 2. Filebeat Test Commandfilebeat configuration 구성에 이상이 없는지 테스트 1./filebeat test config 현재 설정을 사용하여 filebeat가 출력에 연결할 수 있는지 테스트 1./filebeat test output 이와 같이 떠야 테스트 완료 https://www.elastic.co/guide/en/beats/filebeat/current/command-line-options.html 3. 업로드 1./filebeat -e 4. Cilent에서 로그 집계 확인 Menu -&gt; Management - Dev Tools Console 명령 입력 1GET logs_server*/_count 총 1752476건의 로그 집계 확인","link":"/2021/02/23/Elasticsearch-Elasticsearch-Engineer-Training-2/"},{"title":"[Elasticsearch] Elasticsearch Engineer Training -1","text":"본 포스트는 상명대학교 Elasticsearch 엔지니어 트레이닝 과정을 이수하고 작성한 글입니다. 개인이 간단하게 실습을 위해 작성한 포스트이며 Enterprise 급 운용을 위한 글이 아님을 밝힙니다. Day01_ Elasticsearch FundamentalsElastic Stack Overview 검색은 모든 어플리케이션에 있어서 중요하다 루씬은 단순한 라이브러리라면, 엘라스틱 스택은 컴포넌트로 묶어 하나의 클러스터를 만든다. 분산환경이 중요하다. 1. Distributed search 실습환경은 1 node cluster로 구성 10, 100+ 개가 넘는 node cluster도 사용가능하다 (엔터프라이즈 급) 2. Easily used by other languages 엘라스틱이 가지고 있는 프로토콜은 HTTP가 있다. REST API로만 접근 가장 많이 쓰는 method : PUT, POST, GET, DELETE DELETE operation은 조심하여 쓰자. (RESTful 방식의 단점) Elastic Stack Ingest Beats Logstash Store, Search &amp; Analyze Elasticsearch 엘라스틱 스택의 심장 역할 Visualize &amp; Manage Kibana Summary The Elastic Stack is a collection of products with Elasticsearch at the heart. Beats are single purpose data shippers Logstash is a server side data processing pipeline Kibana is an analytics and visualization Getting Started Elasticsearch 루씬 기반이기 때문에 자바 JDK 필수 설치 jvm.options 파일 java와 관련된 환경변수 대부분을 설정 elasticsearch.yml 파일 elasticsearch 실행 환경에 대한 실제 설정 파일 백그라운드 실행1$./bin/elasticsearch -d 노드 이름 만들기1$./bin/elasticsearch -E node.name=ACMEES001 노드 죽이기1$kill `cat elastic.pid` 클러스터 이름 만들기1$./bin/elasticsearch -E cluster.name=acme_logging GCP VM 환경에 Elasticsearch, Kibana 설치와 환경 세팅VM 인스턴스 실행 만들었던 인스턴스 선택 SSH 연결 - 브라우저 창에서 열기 - 터미널 실행 1. Elasticsearch 파일 경로를 가져와 설치(21.02.22 최신버전) wgets 명령어 사용가능 시 사용해도 무방 Linux 64bit 12curl -L -O https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.11.1-linux-x86_64.tar.gz 2. Kibana 파일 경로를 가져와 설치(21.02.22 최신버전) Linux 64bit 1curl -L -O https://artifacts.elastic.co/downloads/kibana/kibana-7.11.1-linux-x86_64.tar.gz 3. 압축 해제12345tar -xzvf elasticsearch-7.11.1-linux-x86_64.tar.gz//..elasticsearch 압축해제..tar -xzvf kibana-7.11.1-linux-x86_64.tar.gz//..Kibana 압축해제.. 4. 다운로드 받았던 설치파일 관리 stack 폴더 만든 후 gz 파일 이동 12mkdir stackmv *.gz ./stack 5. 간단하게 디렉토리 이름 변경12mv elasticsearch-7.11.1/ es-711mv kibana-7.11.1-linux-x86_64/ kb-711 6. elasticsearch에 데이터 저장소 (data, logs) 만들기1234567cd es-711/sudo mkdir /mnt/datasudo chown `owner`:`group` /mnt/datasudo mkdir /mnt/logssudo chown `owner`:`group` /mnt/logsls -al /mnt 로 폴더 생성 확인 Elasticsearch configuration12cd config~/es-711/config &gt;&gt; vi elasticsearch.yml vim 에디터로 수정 ESC -&gt; i 눌러 입력모드 설정 Cluster, Node 이름 변경 데이터, 로그 수집 폴더 경로 설정 네트워크 포트 -&gt; 기본으로 지정된 http.port 값 discovery seed host -&gt; GCP VM 인스턴스 이름 cluster initial master node -&gt; 설정한 node name ESC -&gt; :wq 눌러 저장하고 나가기 Kibana configuration es-711에서 상위 디렉토리로 나가 kb-711 디렉토리로 이동 kb-711/config 디렉토리 이동 1~/kb-711/config$ &gt;&gt; vi kibana.yml server.port : 기본값 server.host : GCP VM 인스턴스 이름 server.name : elasticsearch node name elasticsearch.hosts : [“https://localhost: http.port 값“] Elasticsearch, Kibana 실행GCP 방화벽 설정 GCP VPC 네트워크 - 방화벽 방화벽 규칙 만들기 이름 정하기 대상 : 지정된 대상 태그 대상 태그 : http-server, https-server 소스 필터 : IP 범위 소스 IP 범위 : 0.0.0.0/0 프로토콜 및 포트 tcp 체크 : 80, kibana 기본 포트번호 값 규칙 저장 Compute Engine - VM 인스턴스 수정 http-server, https-server 설정 되어있는지 확인 후 저장 Elasticsearch 실행Kibana 실행 전 무조건 elasticsearch를 올린 후 실행할 것!! 12cd es-711~/es-711$ ./bin/elasticsearch 새로운 터미널 창 열기 elasticsearch 실행 확인 ID와 Password를 이미 설정했다면 security_exeception 예외로 인해 정보를 열람할 수 없다.1curl localhost: `http.port 값` Kibana 실행12cd kb-711~/kb-711$ ./bin/kibana https://VM 외부 IP : kibana 기본 포트번호 로 접속 ID/Password SetupElasticsearch 설정 elasticsearch 인스턴스 종료 elasticsearch.yml 열기 두 줄 옵션 vim editor 맨 아랫줄에 추가 xpack.security.enabled : true xpack.security.transport.ssl.enabled : true 저장 후 종료 (:wq) elasticsearch 인스턴스 실행, 추가 터미널 실행 후 경로 진입, 아래 명령어 입력 1~/es-711/bin$ ./elasticsearch-setup-passwords interactive y 입력 elastic, apm_system, kibana_system, logstash_system, beats_system, remote_monitoring_user 에 대한 패스워드 설정 elasticsearch 인스턴스 재 실행 Kibana 설정 Kibana 인스턴스 종료 kibana.yml 열기 elasticsearch.username : elastic (고정, 건드리지 말 것) elasticsearch.password : 직접 지정해야 함 저장 후 종료 Kibana 인스턴스 재 실행 외부 IP로 재 접속 시 아이디와 패스워드를 묻는 창이 뜬다면 성공","link":"/2021/02/22/Elasticsearch-Elasticsearch-Engineer-Training-1/"},{"title":"[Elasticsearch] Elasticsearch Engineer Training -3","text":"본 포스트는 상명대학교 Elasticsearch 엔지니어 트레이닝 과정을 이수하고 작성한 글입니다. 개인이 간단하게 실습을 위해 작성한 포스트이며 Enterprise 급 운용을 위한 글이 아님을 밝힙니다. Day03Logstash 데이터 파이프라인 도구 실습했던 파일, 표준 입력 외에도 여러가지 input 방법이 존재한다. 데이터 filter 섹션을 잘 작성하는 것이 중요 엘라스틱 서치는 데이터를 가공하는 것에 시간을 많이 써야한다. 읽고자 하는 형식으로 데이터를 가공하지 않으면 나중에 후회한다. logstash는 사용자가 만든 conf 파일을 실행 시 마다 컴파일하고, 라이브러리로 올려 빌드하기 때문에 시간이 많이 소요된다. 따라서 FileBeat로 데이터를 logstash로 보내 필터링을 거쳐 elasticsearch로 보내는 것이 효율적 filebeat.yml의 output.logstash 설정을 logstash를 바라보게 수정. logstash conf 파일 input 섹션에도 Beat로 입력을 받을 준비를 하면 된다. grok filter 일반 표현식 패턴을 사용하여 필드와 구문을 모두 일치시키는 필터 geoip filter IP 주소를 읽어들여 해당 국가 정보를 출력 또한, 사용자의 디바이스, 브라우저 정보 등 여러 Agent 정보를 통해 시각화 가능 데이터 성질과 필드Text와 Keyword의 차이 Text Field : 그룹핑이 필요없고 그냥 읽기만 하면 되는 속성 게시판 제목 사람 이름 Keyword Field : 그룹핑이 필요하고(Category), 집계(Count) 목적이거나, 쪼개서 들어가면 안되는 속성 Song title Company ignore_above Field : 값으로 들어가는 숫자 만큼의 문자열 길이가 아니라면 의미가 없다고 판단하는 속성 데이터에 date 필드가 있다면 date 형태로 저장 새로운 Index 만들어 넣기 - PUT 인덱스는 conf 파일을 넣어 만들 수 있지만 Dev Tools에서 자체적으로 인덱스를 만들어 내는 방법이 있다. HTTP Method 중 하나인 PUT을 사용하여 넣는 법을 알아보자. 아래 형식을 꼭 지켜서 작성해준다. 저장한 인덱스에 Message를 넣어서 생성하고자 한다면 블럭을 넣어 아래와 같이 필드 : 값 형태로 작성한다. 해당 데이터는 _search 연산 시 _source 필드에 저장된다.12345671. PUT _index/_type/_id2. PUT _index/_type/_id { &quot;field&quot; : &quot;value&quot; ... } 저장된 Index 조회하기 - GET1GET _index/_type/_id //PUT으로 저장한 데이터 조회 12GET _index/_searchGET _index/_count Index의 _Settings 1GET _index/_settings number_of_shards : 데이터 Primary Shard number_of_replicas : Optional Shard (노드 손상 시 샤드 데이터를 복구하는 복사본의 수) replica는 하나 이상 원칙 Replica Concept 같은 노드에 프라이머리 샤드와 리플리카는 절대 같이 두면 안된다. 노드 마다 그 노드의 리플리카를 다른 노드로 분산시켜 노드 크래쉬에 대응할 수 있어야 한다. Document는 _id % 샤드 수로 나머지 연산에 의해 분산 저장 서비스의 영속성, 안전성 Elasticsearch Node and ShardsMaster Node 클러스터 안에 여러 노드 존재 my_cluster 안에 node1, node2, node3 Elasticsearch Communication 노드 간의 통신 transport : 노드 사이의 내부 통신 HTTP : REST API로 외부와의 통신 HTTP communication 9200번 포트 사용 Transport communication 9300번 포트 사용 Special values for network settingsDiscovery module Cluster State and Master Nodes1GET _cluster/state 클러스터의 상태 정보값 클러스터 이름 라우팅 테이블 노드 : 노드의 갖은 정보들 스냅샷 : 데이터 loss 방지를 위해 히스토리들을 저장 etc 노드들이 클러스터 상태들을 공유 만약 node1이 클러스터의 마스터 노드일 때 다른 노드들에게 클러스터 상태를 뿌려줌 인덱스 생성 노드들의 이탈, 조인 요청 등의 변경되는 클러스터 상태값들을 담당 두개의 노드들이 하나의 인덱스를 만들기 위해 각각의 샤드들을 페어링 한 상태이다. 그런데 한 노드가 끊어져버렸다고 가정함 페어링된 두개의 샤드 중 하나가 끊어져버려 인덱스를 만들 수 없을 때 여유 공간이 생긴다면 마스터 노드가 담당하여 다시 페어링한다. 마스터 노드는 데이터 저장을 안하기 때문에 해당 노드에는 좋은 하드웨어 스펙을 가질 필요가 없다. Node Roles 마스터 후보 노드 데이터 노드 최근 티어링으로 세분화 됨 데이터의 라이프사이클 관리 측면에서 바뀌게 됨 Ingest 노드 데이터 삽입 용도 PUT Command (Ingesting) indexing 머신 러닝 노드 ML 작업 다른 데이터 대비 이상 징후 관측 변환 노드 데이터 포맷 변환 원격 클러스터 클라이언트 노드 각 클러스터 간 상호 커뮤니케이션 상호 Search Configuring node roles elasticsearch.yml Data Nodes 마스터 노드 역할은 하지 않고 데이터만 저장하는 노드 실제로 인덱싱된 데이터를 저장하고 있는 노드12node.master = falsenode.data = true Ingest Node 로그스태쉬, 파일비트가 없어도 입력된 데이터에 대한 ingest 파이프라이닝이 가능하다 싱글 인스턴스에서도 가능하지만 엘라스틱서치에서 하기에는 리소스 낭비다. Machine Learning Nodes 머신러닝 실행 머신러닝 API 핸들링 node.ml 에서 Configuration Coordinating Node 노드의 수신과 특정 클라이언트의 요청을 핸들링 모든 노드는 암묵적으로 coordinating node이다. 데이터 저장은 필요없음 오로지 Coordinate 역할만 수행 Understanding Shards Index는 Shard 라는 단위로 분산되어 각 Node들에 저장된다. 샤드는 업계 용어이며, 분산 환경에서 많이 쓰임 1PUT sangmyung/_doc/2 1GET indices 12345678910111213노드의 인덱스 모음 디렉토리/mnt/data/nodes/0/indices///1. Dev Tools에서 인덱스 조회하여 PUT operation으로 생성한 인덱스의 uuid값 조회//2. indices 폴더 내에서 생성한 uuid(인덱스 고유번호)를 이름으로 한 디렉토리 찾기/mnt/data/nodes/0/indices///3. 특정 샤드의 위치 /mnt/data/nodes/0/indices/`uuid`/0/index///여러 파일들이 생성됨 어떤 경우로 샤드의 양이 많아지면 성능이 좋지 않을 수 있다. 어떤 파일들이 생성되는지 알고, 샤드 디자인을 잘해야 할 필요가 있다. Primary vs Replica write는 프라이머리 샤드부터, 그다음 Replica Read Throughput을 높이고 싶다면 replica의 양을 늘리면 된다. 어느것을 읽던 같은 데이터이기 때문. Replica 운영 목적에서는 아무 문제 없지만, Crash issue에선 필수적으로 필요하다. 긍정적 의미의 Oversharding 부정적 의미의 Oversharding 서비스에 하루 접속 건수 10건 고가용성 프라이머리 샤드가 있던 노드가 사라져도 같은 정보를 갖고 있는 리플리카가 프라이머리 역할을 대신 할 수 있다. 1GET _cluster/health status : yellow Shard allocation UNASSIGNED 노드 준비 상태 INITIALIZING STARTED 프라이머리가 STARED 되면 리플리카를 만들 수 있는 상태 RELOCATING 여러 노드 중 한 노드가 여유 공간으로 분산되는 상태 사용률이 95% 이상일 때 read는 되지만 write는 안되는 상태 임계치가 넘어가서 샤드의 상태값이 RELOCATED되어 여유 노드를 찾아다니는 상태이다. Node 1, 2에 각 프라이머리와 리플리카가 꽉 차게 저장되어 있을 때 빈 노드 3,4가 들어온다면, Node 1 : P0 RELOCATING 에서 Node 4 : P0 INITIALIZING 되어 옮겨짐 이후 Node 4 P0 STARTED 되고 분산 완료 데이터의 쓰기는 프라이머리가 우선, 노드 하나의 프라이머리가 없고, 리플리카만 존재하면 클러스터엔 Red 상태가 된다. 엘라스틱은 그 때 남아있는 리플리카를 프라이머리로 승격시켜 운용시킨다. Yellow 상태로 변경 Elasticsearch의 자료형 정수 입력은 long 소수점 입력은 float 인덱스를 새로 넣고 mapping12345PUT test-number/_doc/3{ &quot;value&quot; : 15.3}GET test-number/_mapping 저장된 자료형은 float로 저장한다. 1GET test-number/_search 입력한 그대로 값이 조회되는 것을 확인할 수 있다. 하지만 쿼리 시에는 조건에 따라 다르게 조회되는 경우가 발생하므로 주의 Analyzer1`Elasticsearch 엔지니어 트레이닝 코스 오프라인 출석부` Standard analyzer는 text 분석 시 대문자를 만나면 소문자로 변환한다. 띄어쓰기 단위로 토크나이징 keyword 일 때는 변환없이 위 모든 텀이 들어가게 된다. keyword는 서치가 어렵다. English analyzer a, the 같은 관사들은 모두 무시하고 토큰화 단수, 복수형을 무시하고 단어의 어원을 찾음 : Stemming https://www.elastic.co/guide/en/elasticsearch/reference/current/stemming.html 노리 analyzer English analyzer12345GET _analyze { &quot;analyzer&quot;: &quot;english&quot;, &quot;text&quot; : [&quot;Elasticsearch a the 엔지니어 트레이닝 오프라인 교육 출석부&quot;]} standard analyzer12345GET _analyze { &quot;analyzer&quot;: &quot;standard&quot;, &quot;text&quot; : [&quot;Elasticsearch a the 엔지니어 트레이닝 오프라인 교육 출석부&quot;]} 123456GET _analyze { &quot;analyzer&quot;: &quot;standard&quot;, &quot;filter&quot; : [&quot;lowercase&quot;, &quot;asciifolding&quot;] &quot;text&quot; : [&quot;Elasticsearch a the 엔지니어 트레이닝 오프라인 교육 출석부&quot;]}","link":"/2021/02/24/Elasticsearch-Elasticsearch-Engineer-Training-3/"},{"title":"[Elasticsearch] Elasticsearch Engineer Training -4","text":"본 포스트는 상명대학교 Elasticsearch 엔지니어 트레이닝 과정을 이수하고 작성한 글입니다. 개인이 간단하게 실습을 위해 작성한 포스트이며 Enterprise 급 운용을 위한 글이 아님을 밝힙니다. Day04Text Analyzer 2123456GET _analyze { &quot;analyzer&quot;: &quot;standard&quot;, &quot;filter&quot; : [&quot;lowercase&quot;, &quot;asciifolding&quot;] &quot;text&quot; : [&quot;Elasticsearch a the 엔지니어 트레이닝 오프라인 교육 출석부&quot;]} Analysis 과정 로그스태시와 파일비트에서 이벤트 데이터를 입력 Elasticsearch Analysis에서 아래 필터링을 통해 데이터를 파이프라이닝 Character Filter Tokenizer Token Filter Elasticsearch의 Data Node가 수행 Kibana AnalyticsDiscover","link":"/2021/02/25/Elasticsearch-Elasticsearch-Engineer-Training-4/"},{"title":"[안드로이드] 프레임 레이아웃과 뷰의 전환","text":"프레임 레이아웃과 뷰의 전환 프레임 레이아웃 (Frame Layout) 뷰를 여러개 추가하게 되면, 나머지 뷰들이 가장 마지막에 추가한 뷰 아래 쪽에 중첩되어 쌓이게 된다. 뷰를 보여주거나 안보여줄 수 있는 속성을 가시성, visibility 속성 라고 한다. FrameLayout은 가시성 속성과 함께 사용하게 된다. 뷰들을 여러개 담아놓고 중첩시킬 때 주로 사용하게 된다. 프레임 레이아웃 실습 activity_main.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &gt; &lt;Button android:id=&quot;@+id/Button1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentStart=&quot;true&quot; android:layout_alignParentTop=&quot;true&quot; android:onClick=&quot;onButton1Clicked&quot; android:text=&quot;이미지 바꾸기&quot; /&gt; &lt;FrameLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;557dp&quot; android:layout_below=&quot;@+id/Button1&quot; android:layout_alignParentStart=&quot;true&quot; android:layout_centerHorizontal=&quot;true&quot; android:layout_marginTop=&quot;36dp&quot; android:layout_marginEnd=&quot;24dp&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/Button1&quot;&gt; &lt;ImageView android:id=&quot;@+id/imageView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:src=&quot;@drawable/dream01&quot; android:visibility=&quot;invisible&quot; /&gt; &lt;ImageView android:id=&quot;@+id/imageView2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:src=&quot;@drawable/dream02&quot; android:visibility=&quot;visible&quot; /&gt; &lt;/FrameLayout&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 제약 레이아웃 내부에 버튼을 하나 만들었다. 해당 버튼을 누르면 이미지가 바뀌도록 버튼 아래에 프레임 레이아웃을 크기를 조절하여 두었다. 그리고 ImageView 2개를 만들어 프레임 레이아웃 내부에 이미지 두개를 전환할 수 있도록 만들 것이다. 프레임 레이아웃은 가시성 속성을 통해 중첩된 뷰를 보여주거나, 안보여줄 수 있게 기능하도록 하기 때문에 imageView는 invisible. imageView2는 visible 속성으로 설정했다. MainActivity.java 12345678910111213141516171819202122232425262728293031323334353637import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.ImageView;public class MainActivity extends AppCompatActivity { ImageView imageView; ImageView imageView2; //어떤 이미지가 선택되었는지 알려주는 변수 int index = 0; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //id를 이용하여 뷰를 찾아주세요 imageView = (ImageView)findViewById(R.id.imageView); imageView2 = (ImageView)findViewById(R.id.imageView2); } public void onButton1Clicked (View v) { index += 1; if (index &gt; 1) { index = 0; } if (index == 0) { imageView.setVisibility(View.VISIBLE); imageView2.setVisibility(View.INVISIBLE); } else if (index == 1) { imageView.setVisibility(View.INVISIBLE); imageView2.setVisibility(View.VISIBLE); } }} imageView를 가져올 전역 변수 어떤 이미지가 선택 되었는지 알려주는 index 변수 초기화 findViewById 메소드를 통해 resource 파일의 id를 리턴 받아 imageView를 가져오도록 한다. Button에 onClick 속성으로 onButton1Clicked를 작성한다. onButton1Clicked 메소드 버튼을 누를때마다 index 변수 값 증가 만약 인덱스 값이 1보다 크면 0으로 초기화 만약 값이 0이면 imageView 사진 출력 만약 값이 1이면 imageView2 사진 출력","link":"/2021/03/08/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%ED%94%84%EB%A0%88%EC%9E%84-%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83%EA%B3%BC-%EB%B7%B0%EC%9D%98-%EC%A0%84%ED%99%98/"}],"tags":[{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"명령어","slug":"명령어","link":"/tags/%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"name":"협업","slug":"협업","link":"/tags/%ED%98%91%EC%97%85/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"Hypertext","slug":"Hypertext","link":"/tags/Hypertext/"},{"name":"백준","slug":"백준","link":"/tags/%EB%B0%B1%EC%A4%80/"},{"name":"BOJ","slug":"BOJ","link":"/tags/BOJ/"},{"name":"알고리즘","slug":"알고리즘","link":"/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Stack","slug":"Stack","link":"/tags/Stack/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Blog","slug":"Blog","link":"/tags/Blog/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"plugin","slug":"plugin","link":"/tags/plugin/"},{"name":"안드로이드","slug":"안드로이드","link":"/tags/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C/"},{"name":"intent","slug":"intent","link":"/tags/intent/"},{"name":"데이터통신","slug":"데이터통신","link":"/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%86%B5%EC%8B%A0/"},{"name":"코틀린","slug":"코틀린","link":"/tags/%EC%BD%94%ED%8B%80%EB%A6%B0/"},{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"},{"name":"SEO","slug":"SEO","link":"/tags/SEO/"},{"name":"액션바","slug":"액션바","link":"/tags/%EC%95%A1%EC%85%98%EB%B0%94/"},{"name":"상단바","slug":"상단바","link":"/tags/%EC%83%81%EB%8B%A8%EB%B0%94/"},{"name":"Gradle","slug":"Gradle","link":"/tags/Gradle/"},{"name":"SHA1","slug":"SHA1","link":"/tags/SHA1/"},{"name":"SHA256","slug":"SHA256","link":"/tags/SHA256/"},{"name":"조회수","slug":"조회수","link":"/tags/%EC%A1%B0%ED%9A%8C%EC%88%98/"},{"name":"방문자수","slug":"방문자수","link":"/tags/%EB%B0%A9%EB%AC%B8%EC%9E%90%EC%88%98/"},{"name":"권한","slug":"권한","link":"/tags/%EA%B6%8C%ED%95%9C/"},{"name":"permission","slug":"permission","link":"/tags/permission/"},{"name":"manifest","slug":"manifest","link":"/tags/manifest/"},{"name":"자료구조","slug":"자료구조","link":"/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"성능분석","slug":"성능분석","link":"/tags/%EC%84%B1%EB%8A%A5%EB%B6%84%EC%84%9D/"},{"name":"최악의경우","slug":"최악의경우","link":"/tags/%EC%B5%9C%EC%95%85%EC%9D%98%EA%B2%BD%EC%9A%B0/"},{"name":"Time Complexity","slug":"Time-Complexity","link":"/tags/Time-Complexity/"},{"name":"빅오표기법","slug":"빅오표기법","link":"/tags/%EB%B9%85%EC%98%A4%ED%91%9C%EA%B8%B0%EB%B2%95/"},{"name":"빅오메가표기법","slug":"빅오메가표기법","link":"/tags/%EB%B9%85%EC%98%A4%EB%A9%94%EA%B0%80%ED%91%9C%EA%B8%B0%EB%B2%95/"},{"name":"빅세타표기법","slug":"빅세타표기법","link":"/tags/%EB%B9%85%EC%84%B8%ED%83%80%ED%91%9C%EA%B8%B0%EB%B2%95/"},{"name":"배열","slug":"배열","link":"/tags/%EB%B0%B0%EC%97%B4/"},{"name":"array","slug":"array","link":"/tags/array/"},{"name":"추가","slug":"추가","link":"/tags/%EC%B6%94%EA%B0%80/"},{"name":"검색","slug":"검색","link":"/tags/%EA%B2%80%EC%83%89/"},{"name":"제거","slug":"제거","link":"/tags/%EC%A0%9C%EA%B1%B0/"},{"name":"연결리스트","slug":"연결리스트","link":"/tags/%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8/"},{"name":"list","slug":"list","link":"/tags/list/"},{"name":"linkedlist 추가","slug":"linkedlist-추가","link":"/tags/linkedlist-%EC%B6%94%EA%B0%80/"},{"name":"프로그래머스","slug":"프로그래머스","link":"/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"정렬","slug":"정렬","link":"/tags/%EC%A0%95%EB%A0%AC/"},{"name":"sort","slug":"sort","link":"/tags/sort/"},{"name":"copyOfRange()","slug":"copyOfRange","link":"/tags/copyOfRange/"},{"name":"long","slug":"long","link":"/tags/long/"},{"name":"integer","slug":"integer","link":"/tags/integer/"},{"name":"parse","slug":"parse","link":"/tags/parse/"},{"name":"ascii","slug":"ascii","link":"/tags/ascii/"},{"name":"atoi","slug":"atoi","link":"/tags/atoi/"},{"name":"equals()","slug":"equals","link":"/tags/equals/"},{"name":"&#x3D;&#x3D;","slug":"","link":"/tags/"},{"name":"isLowerCase()","slug":"isLowerCase","link":"/tags/isLowerCase/"},{"name":"isUpperCase()","slug":"isUpperCase","link":"/tags/isUpperCase/"},{"name":"tags","slug":"tags","link":"/tags/tags/"},{"name":"View","slug":"View","link":"/tags/View/"},{"name":"뷰","slug":"뷰","link":"/tags/%EB%B7%B0/"},{"name":"제약 레이아웃","slug":"제약-레이아웃","link":"/tags/%EC%A0%9C%EC%95%BD-%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83/"},{"name":"Constraint Layout","slug":"Constraint-Layout","link":"/tags/Constraint-Layout/"},{"name":"핸들","slug":"핸들","link":"/tags/%ED%95%B8%EB%93%A4/"},{"name":"앵커 포인트","slug":"앵커-포인트","link":"/tags/%EC%95%B5%EC%BB%A4-%ED%8F%AC%EC%9D%B8%ED%8A%B8/"},{"name":"bias","slug":"bias","link":"/tags/bias/"},{"name":"레이아웃","slug":"레이아웃","link":"/tags/%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83/"},{"name":"Layout","slug":"Layout","link":"/tags/Layout/"},{"name":"LinearLayout","slug":"LinearLayout","link":"/tags/LinearLayout/"},{"name":"RelativeLayout","slug":"RelativeLayout","link":"/tags/RelativeLayout/"},{"name":"FrameLayout","slug":"FrameLayout","link":"/tags/FrameLayout/"},{"name":"TableLayout","slug":"TableLayout","link":"/tags/TableLayout/"},{"name":"Elastic","slug":"Elastic","link":"/tags/Elastic/"},{"name":"Elasticsearch","slug":"Elasticsearch","link":"/tags/Elasticsearch/"},{"name":"GCP","slug":"GCP","link":"/tags/GCP/"},{"name":"Google Cloud Platform","slug":"Google-Cloud-Platform","link":"/tags/Google-Cloud-Platform/"},{"name":"Kibana","slug":"Kibana","link":"/tags/Kibana/"},{"name":"Logstash","slug":"Logstash","link":"/tags/Logstash/"},{"name":"Beats","slug":"Beats","link":"/tags/Beats/"},{"name":"Filebeat","slug":"Filebeat","link":"/tags/Filebeat/"},{"name":"Pipeline","slug":"Pipeline","link":"/tags/Pipeline/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Vim","slug":"Vim","link":"/tags/Vim/"}],"categories":[{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"HTML&#x2F;CSS","slug":"HTML-CSS","link":"/categories/HTML-CSS/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"BOJ","slug":"Algorithm/BOJ","link":"/categories/Algorithm/BOJ/"},{"name":"Data Structure","slug":"Data-Structure","link":"/categories/Data-Structure/"},{"name":"Programmers","slug":"Algorithm/Programmers","link":"/categories/Algorithm/Programmers/"},{"name":"Elastic","slug":"Elastic","link":"/categories/Elastic/"}]}