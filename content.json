{"pages":[{"title":"about","text":"안녕하세요 개발자를 꿈꾸고 있는 문도니입니다.그동안 배워 오고 공부해온 것들을 정리 해야겠다는 생각이 들었어요. 컴퓨터를 전공한 학생들은 과제나 학업을 위해 블로그를 뒤적거리고, 개발자들은 앞에 놓인 문제에 빠르게 대응하기 위해 잘 정리 되어진 블로그를 찾기 마련입니다.길을 잃은 IT직군 희망자/종사자 분들의 길잡이가 되고 저 또한 제가 닦아 놓은 길을 다시 되돌아 볼 수 있는 곳. 저도 그런 블로그를 만들고 싶어졌습니다.학부 4학년을 바라보는 이 시점에서 제가 배운 것은 얼마나 많고, 제 머릿속에서 꺼내 쓸 수 있는 지식들은 얼마나 될지 기록해보고 싶어졌습니다. 직면한 문제를 풀 수 있게 만들어주는 블로그인턴하면서 해결해야 할 문제가 많았습니다. 모르는 지식이 있다면 사수에게 무작정 물어보는 것보다 자기가 처한 문제를 키워드 화 하여 구글링 할 수 있는, 스스로 해결해 보는 능력을 길렀다고 해도 과언이 아닙니다. 사수에게 물어보는 건 “~~ 하여 고민해봤지만 잘 안됐습니다. 알려주시면 감사하겠습니다.” 하는 것은 그 후에 일이죠. 그런 문제들을 해결할 수 있게 도와준 블로그가 있다는 것에 감사하는 마음이 있었습니다. Footprints 상명대학교 컴퓨터과학과 재학 중 (2015/03 ~ ) 멋쟁이 사자처럼 7기 / Hackathon 참여 (2019/03 ~) ‘R’ 보안솔루션 기업 인턴 - QA Tester (2019/07 ~ 2020/01 : 6개월) : 전반적인 IT 회사에서의 개발 프로세스 경험.","link":"/about/index.html"}],"posts":[{"title":"[BOJ] 10828번 - 스택","text":"학부생 때 배웠던 스택 자료구조 이론을 토대로 스택 배열 생성, push , pop 연산 등을 구현해보는 문제였다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Scanner;public class Main { public static void main(String[] args){ Scanner sc = new Scanner(System.in); int num = sc.nextInt(); int top = -1; int[] stack = new int[num]; for (int i=0; i&lt;num; i++){ String input = sc.next(); if (input.equals(\"push\")){ stack[++top] = sc.nextInt(); } else if (input.equals(\"pop\")) { if (top == -1) { System.out.println(-1); } else { System.out.println(stack[top]); top--; } } else if (input.equals(\"size\")) { System.out.println(top+1); } else if (input.equals(\"empty\")) { if (top == -1){ System.out.println(1); } else { System.out.println(0); } } else if (input.equals(\"top\")){ if (top == -1) { System.out.println(-1); } else { System.out.println(stack[top]); } } } }}","link":"/2020/02/12/BOJ-10828%EB%B2%88-%EC%8A%A4%ED%83%9D/"},{"title":"[Hexo Blog] Markdown 플러그인 설치","text":"마크다운은 간단한 인라인 코드를 작성할 때 백틱을 이용한다. 1`(넣을 내용)` 근데 잘 쓰고 있던 중 어떤 md 파일은 먹히는데 새로 작성하는 파일에선 되지 않는 현상을 발견했다. 구글링을 통해 삽질을 해본 결과 기본 hexo는 원래 해당 태그를 지원하지 않는다는 사실을 어느 블로그를 통해 알게 되었고 당장 hexo 용 마크다운 플러그인을 설치했다. 참조 : https://d2fault.github.io/2018/07/03/20180703-smart-posting/ Installhttps://github.com/CHENXCHEN/hexo-renderer-markdown-it-plushexo가 설치 된 루트 폴더 (블로그 theme 상단 경로)에 아래 npm 명령을 입력한다. 12npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it-plus --save _config.yml 설정1234567891011#Markdown 플러그인 설치markdown_it_plus: highlight: true html: true xhtmlOut: true breaks: true langPrefix: linkify: true typographer: quotes: “”‘’ pre_class: highlight _config.yml 파일 최하단에 다음 구문을 넣어 설정한다.","link":"/2020/01/28/Hexo-Blog-Markdown-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-%EC%84%A4%EC%B9%98/"},{"title":"[Hexo Blog] 블로그 방문자 및 조회수 카운팅 기능 넣기 (Busuanzi)","text":"해당 포스트는 Hexo theme 중 icarus 테마에 적용한 내용입니다. 지원이 되지 않거나, 설정 방법에서 약간의 차이가 있을 수 있습니다. 간단하게 블로그 하단에 방문하신 분들이 몇 명이나 되었는지, 또한 글을 얼마나 봐주셨는지에 대해 간단히 표시할 수 있는 기능을 설정하는 법을 알아보자. Busuanzihexo 프레임워크가 애초에 중국에서 만들어졌다보니 웹페이지에 필요한 라이브러리 중 방문자, 조회수 카운팅 기능도 중국 라이브러리라는 것을 알게되었다. Busuanzi 공식 사이트 : https://busuanzi.ibruce.info/ Busuanzi 사용 법 기술 사이트 : http://ibruce.info/2015/04/04/busuanzi/ 설정먼저 theme\\_config.yml 로 들어가 busuanzi 섹션을 찾고 해당 기능을 true로 상태를 활성화 시킨다.그 다음 theme\\layout\\common\\footer.ejs 에서 몇가지 구문을 넣어준다. 123456789&lt;% if (busuanzi) { %&gt; &lt;!--만약 busuanzi 가 활성화됐으면--&gt; &lt;br&gt; &lt;span id=\"busuanzi_container_site_pv\"&gt; 총 조회 &lt;span id=\"busuanzi_container_site_pv\"&gt;&lt;/span&gt; 회 &lt;/span&gt; | &lt;span id=\"busuanzi_container_site_uv\"&gt; 총 방문자 &lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt; 명 &lt;/span&gt; &lt;% } %&gt; 아직 많은…분들께서 방문해주시지 못했지만 이렇게 기능이 추가된 것을 볼 수 있다.열심히 노력하자!","link":"/2020/02/15/Hexo-Blog-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%B0%A9%EB%AC%B8%EC%9E%90-%EB%B0%8F-%EC%A1%B0%ED%9A%8C%EC%88%98-%EC%B9%B4%EC%9A%B4%ED%8C%85-%EA%B8%B0%EB%8A%A5-%EB%84%A3%EA%B8%B0/"},{"title":"[프로그래머스] K번째 수","text":"배열 array를 i번째 부터 j번째 까지 자르고 정렬했을 때, k번째에 있는 수를 구한다. commands 배열의 각 행, 즉 i,j,k를 잘 뽑아내고 정렬 후 k번째 수를 answer 배열에 넣기만 하면 된다. i, j, k 명령 수행 시 k번째 수는 ‘하나’가 나오게 된다. commands의 길이는 1~50 이하 이므로 k번째 수를 담는 answer 배열의 크기는 commands.length 만큼 할당해야 한다. 그리고 i, j, k 값들을 각각 치환하여 사용하기 쉽게 만들었다. 또한 i번째 부터 j번-[ys.copyOfRange() 함수를 사용했다. 말 그대로 구간을 정해 copy하는 함수다. 첫번째 인자부터 배열의 주소(이름), 시작 인덱스, 종료 인덱스(종료 인덱스는 구간에 포함하지 않는다.) 이다. 12int[] array2 = Arrays.copyOfRange(array,i-1,j); // 배열은 0부터 시작하므로 i-1 한다. Arrays.sort() 해주고, k번째 (k-1번째 index) 수를 answer 배열에 넣고 return 해주면 된다 123456789101112131415161718import java.util.Arrays;class Solution { public int[] solution(int[] array, int[][] commands) { int[] answer = new int[commands.length]; for (int index = 0; index&lt;commands.length; index++){ int i = commands[index][0]; int j = commands[index][1]; int k = commands[index][2]; int[] array2 = Arrays.copyOfRange(array,i-1,j); Arrays.sort(array2); answer[index] = array2[k-1]; } return answer; }}","link":"/2020/01/27/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-K%EB%B2%88%EC%A7%B8-%EC%88%98/"},{"title":"[Hexo Blog] 구글 사이트 등록 및 검색엔진 최적화(SEO)","text":"Hexo 블로그를 만들었다면 구글에 키워드 서칭 시 내 블로그가 검색이 잘 되도록 하는 과정을 알아보자. 검색 최적화구글 같은 검색 엔진을 주로 서비스하는 사이트들은 크롤링 이라고 하는 작업을 통해 여러 웹사이트나 블로그 들의 정보를 검색 엔진에 수집해서 사람들이 검색을 할 시 해당 사이트들을 사용자들에게 노출시킨다고 한다. 일단 기술 블로그만 만들면 장땡일 줄 알았는데 막상 이런 작업을 하려고 하니 막막하지만 블로그를 좀 더 개선할 수 있는 방법이기 때문에 바로 시작한다.구글에 Hexo만 검색해도 검색엔진 최적화 라는 방법들을 여러 사람들이 쓰는 것을 알 수 있었는데, 줄여서 SEO 라고 한다. 즉 Search Engine Optimization 은 검색엔진에 맞게 사이트를 제작, 운영하는 과정 전부를 말한다.SEO 과정을 시작하기 위해서는 Hexo 프로젝트에 몇가지 플러그인 설치가 필요하다. 플러그인 설치hexo-auto-canonical메타 태그 중 canonical 속성을 대표 URL이라 뜻하고 각 포스트마다 자동으로 표준 링크를 만들어 준다. 설치 npm-install --save hexo-auto-canonical 설정설정은 내 블로그 테마 기준, theme 폴더 아래의 layout/common/head.ejs 파일에서 제일 하단에 구문을 추가한다. 12&lt;!--Canonical : 유사하거나 중복된 페이지의 표준 페이지 정의--&gt;&lt;%- autoCanonical(config, page) %&gt; head.ejs 구문을 만지작하고 deploy 하니 head 태그 아래에 &lt;link rel=&quot;canonical&quot; href=&quot;https://msj0319.github.io/&quot;&gt; 라고 설정이 된 것을 확인할 수 있다. 메타 태그 (meta tag)는 해당 웹 페이지의 정보를 담은 태그로 &lt;head&gt; 태그 안에 있다고 한다. 이 메타 태그가 잘 들어가 있어야 검색엔진이 이 사이트를 잘 인식해서 수집이 잘된다고 한다. 참조 : https://futurecreator.github.io/2016/06/15/hexo-google-site-search-console-analytics/ 웹 개발 쪽은 잘 몰랐는데 여러 ejs 파일들이 이런 식으로 각자 할일들이 있는 모양새인듯 하다. 시간나면 공부해 봐야겠다. hexo-autofollow해당 포스트에서 참고하고 있는 외부링크에 대해 nofollow 속성을 자동으로 추가하는 플러그인이다. 앞서 언급했듯이 검색엔진은 사람들이 서칭활동을 하는데에 있어 원하는 웹페이지를 되도록 많이 수집하는데 이런 크롤링 작업을 하는 로봇을 크롤러 또는 구글봇이라고 한다. 이런 로봇에게 어떤 페이지는 수집하지 말라고 얘기할 필요가 있기 때문에 이런 기능이 필요한 것이다. 설치 npm install hexo-autonofollow --save 설정 (theme/_config.yml)12345nofollow: enable: true exclude: - exclude_1.com #예외처리 할 사이트 등록 - exclude_2.com hexo-generator-seo-friendly-sitemapSitemap 생성기, 사이트맵을 등록하면 크롤링 작업을 하는 봇들이 좀 더 효율적으로 크롤링 작업을 할 수 있게 도와주는 역할을 한다. 설치 npm-install hexo-generator-seo-friendly-sitemap --save 설정 (theme/_config.yml)123456# 검색 엔진에서 크롤링 할 페이지들을 결정해주는 xml 파일 생성sitemap: path: sitemap.xml #블로그 주소/sitemap.xml #여기까지만 쓴다. 아래는 옵션 tag: true #Defualt: true category: true #Default: true tag 속성 : sitemap에 tag 정보 포함 여부category 속성 : sitemap에 마찬가지로 카테고리 포함 여부 (실제로 root 폴더 내부에 sitemap.xml 파일들이 생성된 것이 보인다.) hexo-generator-feed자동으로 Atom 1.0 또는 RSS2.0 피드 생성해주는 플러그인이다. 설치 npm install hexo-generator-feed --save 설정 (theme/_config.yml)123456789feed: type: rss2 #atom / rss2 path: rss2.xml #(Defult: atom.xml/rss2.xml) - 네이버에선 atom 미지원으로 인해 rss2로 설정 limit: 20 #공개할 rss feed 수 # 기본적으로 여기 까지만 쓴다. 아래는 옵션 hub: content: content_limit: 140 #요약 글자 수 content_limit_delim: '' root/_config.yml12# Path or URL to RSS atom.xmlrss: /rss2.xml #feed에서 등록한 rss 주소 입력 hexo-generator-robotstxt설치 npm install hexo-generator-robotstxt --save 설정1234robotstxt: User-agent: \"*\" Allow: / Sitemap: https://msj0319.github.io/sitemap.xml Sitemap 속성엔 미리 Sitemap 플러그인 설치 후 설정한 사이트맵의 주소를 넣는다. 그 뜻은 robots 생성 플러그인 설치를 위해선 사이트맵 플러그인 설치가 선행되어야 한다.설정이 모두 끝난 후 Deploy를 하면 모든 검색엔진 최적화를 위한 플러그인 설치는 끝난다.","link":"/2020/02/14/Hexo-Blog-%EA%B5%AC%EA%B8%80-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EB%93%B1%EB%A1%9D-%EB%B0%8F-%EA%B2%80%EC%83%89%EC%97%94%EC%A7%84-%EC%B5%9C%EC%A0%81%ED%99%94-SEO/"},{"title":"[프로그래머스] 나머지 한 점","text":"직사각형을 만드는데 필요한 4개의 점 중 3개만 주어질 때, 주어지는 3개의 점들은 모두 각 x축 y축에 평행 하도록 하는 좌표만 주므로, 만약 [[1,4],[3,4],[3,10]] 이 주어졌을 때 중복 되는 배열의 원소 수는 소거한다. 그럼 중복 되지 않는 수가 나머지 한 점 이 된다.그러므로 [1,10] 이 output으로 나와야 한다. 주어진 2차원 배열을 비정방형 행렬로 생각하여 풀어보자. 1234 x좌표 y좌표v = [[1, 4] [0][0] [0][1] [3, 4] == [1][0] [1][1] [3,10]] [2][0] [2][1] 1234567891011121314151617181920212223242526272829class Solution { public int[] solution(int[][] v) { int x, y; // x좌표값 찾기 if (v[0][0]==v[1][0]){ x = v[2][0]; } else if (v[0][0]==v[2][0]){ x = v[1][0]; } else x = v[0][0]; //y좌표값 찾기 if(v[0][1] == v[1][1]){ y = v[2][1]; } else if(v[0][1]==v[2][1]){ y = v[1][1]; } else y = v[0][1]; int[] answer = {x,y}; return answer; }} XOR 연산자 사용하여 문제해결 12345678910111213class Solution { public int[] solution(int[][] v) { int[] answer = {0,0}; //좌표는 총 3개가 입력으로 주어지므로 반복을 3번 돌린다. for (int i=0; i&lt;3; i++){ answer[0] ^= v[i][0]; answer[1] ^= v[i][1]; } return answer; }}","link":"/2020/01/22/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%82%98%EB%A8%B8%EC%A7%80-%ED%95%9C-%EC%A0%90/"},{"title":"[프로그래머스] 문자열 다루기 기본","text":"문자열 다루기 기본 문제라는 문제 이름으로 쉬운 문제라고 생각하고 풀었다. 아스키코드 상으로 알파벳 소문자 또는 대문자가 문자열 안에 존재하면 answer 상태를 false로 바꿔주고 리턴까지 시켰다. 하지만 주어진 테스트 케이스를 통과하였지만 자꾸 테스트 5,6번에서 막혔고 이유가 뭔지 골똘히 생각하던 중에 그 이유를 찾을 수 있었다. 1문자열 s의 길이가 4 혹은 6이고, 숫자로만 구성되어 있는지 확인하는 함수, solution을 완성하세요. 아뿔싸. 문자열 s의 길이가 4또는 6인지 확인하는 구문을 넣지 않았다…해당 문제의 질문하기에는 쉬운 문제임에도 불구하고 많은 사람들이 “왜 테스트케이스 5,6번에서 막히는 거죠?” 라는 바보같은 질문을 올려댔다. 나도 그 이유를 몰라 찾아 해맸고 탄식이 나올 정도로 어이없었다. 다음부턴 입출력만 보고 문제를 푸는 습관은 고쳐야겠다 라는 당연한 생각을 했다. 1234567891011121314151617class Solution { public boolean solution(String s) { boolean answer = true; if (s.length() == 4 || s.length() == 6) { for (int i=0; i&lt;s.length(); i++){ if((65&lt;= s.charAt(i) &amp;&amp; s.charAt(i) &lt;= 90) || (97&lt;= s.charAt(i) &amp;&amp; s.charAt(i) &lt;= 122)){ answer = false; break; } } return answer; } else answer = false; return answer; }}","link":"/2020/02/07/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%8B%A4%EB%A3%A8%EA%B8%B0-%EA%B8%B0%EB%B3%B8/"},{"title":"[프로그래머스] x만큼 간격이 있는 n개의 숫자","text":"문제 자체는 쉬웠지만 자칫 그냥 써버릴 수 있는 int 타입이 입력 변수 범위가 제한조건에 걸려 테스트케이스에서 실패를 했었던 문제다. 12345678910class Solution { public long[] solution(long x, int n) { long[] answer = new long[n]; for(int i=0; i&lt;n; i++){ answer[i] = x*(i+1); } return answer; }} 핵심 연산을 해주는 answer[i] = x*(i+1) 에서 반복문을 세주는 i가 int형이고 만약 x도 int형일 때 x*(i+1) 연산에서 answer[i] 값은 곱했을 때 당연히 int가 된다. (배열 선언은 long으로 해줬으면서 말이다.) 그래서 answer 배열은 n만큼 할당해줘야 하기에 solution의 변수 n을 int로 놔뒀고, 제한조건 범위 내의 연산을 위해(long 타입 연산을 위해) long 타입으로 바꿨다.","link":"/2020/02/07/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-x%EB%A7%8C%ED%81%BC-%EA%B0%84%EA%B2%A9%EC%9D%B4-%EC%9E%88%EB%8A%94-n%EA%B0%9C%EC%9D%98-%EC%88%AB%EC%9E%90/"},{"title":"[프로그래머스] 서울에서 김서방 찾기","text":"서울에서 김서방 찾기… 금방 풀었다라고 생각했고 테스트 통과까지 했다.하지만 정확성 테스트에서 털려버렸고 이유는 질문하기에서 금방 찾을 수 있었다. 그것은 바로 String 비교 문제에서 항등 연산자로 문제를 풀었던 것이다. 123456789101112131415//오답 코드 (정확성 테스트 실패)class Solution { public String solution(String[] seoul) { String answer = \"\"; int i = 0; for (i=0; i&lt;seoul.length; i++){ if (seoul[i] == \"Kim\"){ //문제의 그 부분 break; } answer = \"김서방은 \"+i+\"에 있다\"; } return answer; }} 자바에서 String을 비교할 때, .equals() 는 객체끼리 내용(값)을 비교할 수 있는 메소드이고(값 자체를 비교), == 는 객체의 참조(주소)값을 비교하는 연산자이다. 무심코 생각못하고 실전에서 이런 실수를 해버렸다면 정말 끔찍했을 것이다. 1234567891011121314//솔루션class Solution { public String solution(String[] seoul) { String answer = \"\"; String kim = \"Kim\"; int i = 0; for (i=0; i&lt;seoul.length; i++){ if (seoul[i].equals(kim)){ answer = \"김서방은 \"+i+\"에 있다\"; //띄어쓰기 주의 } } return answer; }}","link":"/2020/01/26/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%84%9C%EC%9A%B8%EC%97%90%EC%84%9C-%EA%B9%80%EC%84%9C%EB%B0%A9-%EC%B0%BE%EA%B8%B0/"},{"title":"[프로그래머스] 문자열을 정수로 바꾸기","text":"문자열의 길이는(s는) 1~5이고, s 맨 앞에는 부호(+,-)가 올 수 있다고 한다.부호에 따른 처리가 필요한 것인지 궁금했지만 일단 매개변수로 받은 문자열 s를 정수로 casting 해보았다. 123456789import java.util.*;class Solution { public int solution(String s) { int answer = 0; answer = Integer.parseInt(s); return answer; }} 우선 이렇게 코딩 후 실행하니 테스트케이스를 전부 통과했고, 놀랍게도 제출하니 정답으로 통과했다.하지만 남들이 푼 코드를 보니 API에 의존한 내가 너무 부끄럽게 느껴질 정도였다.남들이 푼 코드 중 하나를 가져와서 atoi에 대해 다시 한번 익혀보도록 하자. 12345678910111213141516171819public class Solution { public int solution(String str) { boolean plus = true; int value = 0; for (char ch : str.toCharArray()) { if (ch == '-') { plus = false; } else { int num = ch - 48; value = num+value*10; } } return (plus==true)? value : -1*value; }} 매개변수 문자열 str을 toCharArray로 문자로 char 변수에 받은 후 - 부호가 존재하면 plus 상태를 false라고 해주고 만약 +부호 일때는 if문을 벗어난다.문자 중 부호가 없으면 else 문으로 진입하게 되는데, 여기서부터가 atoi의 핵심이다. 12345678for (char ch : str.toCharArray()) { if (ch == '-') { plus = false; } else { int num = ch - 48; value = num+value*10; } String 객체에 담긴 문자열이 int 형 변수에 Integer로 Casting 되는 과정이다. 123456//ex) String = 12result = 0; //초기값result = (result * 10) + '1' - 48; //1result = (1 * 10) + '2' - 48; //12//result의 최종 결과 값은 12 초반에 result에 10을 곱해주는 이유는 Decimal 데이터를 얻어야 하기에 그렇다.또한 아스키코드 상에서 48은 문자열 0이므로 문자열 1(49)에서 문자열 0(48)을 빼주면 정수 1이 출력될 수 있다. 마지막으로 plus 상태가 true이면 바로 value 출력, false면 value에 -1을 곱한 후 리턴해주면 된다.","link":"/2020/02/06/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%AC%B8%EC%9E%90%EC%97%B4%EC%9D%84-%EC%A0%95%EC%88%98%EB%A1%9C-%EB%B0%94%EA%BE%B8%EA%B8%B0/"},{"title":"[프로그래머스] 수박수박수박수박수박수?","text":"입력 n이 1일 땐 “수” 출력, n이 2이면 “수박”, 3이면 “수박수” … index 초기값을 1로 초기화 하고 반복문을 통해 i가 증가 할때마다 홀수, 짝수 판별을 한다. 만약 홀수면 “수”, 짝수면 “박”을 answer 에 추가해가면서 n번 반복한다. 12345678910111213class Solution { public String solution(int n) { String answer = \"\"; for (int i = 1; i &lt;= n; i++){ if (i % 2 == 1) { answer += \"수\"; } else { answer += \"박\"; } } return answer; }}","link":"/2020/02/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%88%98%EB%B0%95%EC%88%98%EB%B0%95%EC%88%98%EB%B0%95%EC%88%98%EB%B0%95%EC%88%98%EB%B0%95%EC%88%98/"},{"title":"[프로그래머스] 시저 암호","text":"아스키를 잘 다룬다면 쉬운 문제겠지만 잘 못다룬다면 어려운 문제일 수 있겠다. 문자열과 정수를 입력받아 정수 만큼 다음 문자로 밀어주는 (예를 들면 A가 2만큼 이동하면 C) 카이사르 암호 문제이다. 이 문제에서 잘 생각해야 하는 부분은 알파벳에서 소문자 대문자를 포함하지 않는다면 A 부터 Z까지 모두 26자 이다. 여기서 Z에서 정수 1을 받게 되면 A로 다시 돌아와야 한다. 그렇기 때문에 입력 받은 n을 밀어낼 자리 수 계산을 위해 n = n % 26 을 이용. 26(Z)이 넘어가게 되면 나머지 값 1 , 즉 A 부터 다시 출력 할 수 있게 한다. 문자열 s의 길이 만큼 반복하고, char 변수에 문자열에서 문자 하나를 받아 소문자, 대문자를 판별한다. 사용한 라이브러리 함수는 isLowerCase(), isUpperCase() 이다. boolean 타입이며 각각 소문자면 해당 문자가 소문자, 대문자면 true, false를 내보낸다. 그 후 이동시킬 알파벳 ch에서 ‘A’ 또는 ‘a’를 빼고 밀어줄 n값을 더한 후 전체 알파벳 수(26)로 나눈 나머지를 구하면 이동할 거리가 완벽하게 계산된다. 그걸 다시 초기값 ‘A’ 또는 ‘a’에 더해주면 ch 문자로부터 n만큼 이동한 알파벳이 나오게 된다. 마지막으로 입력 받았을 때 공백이 포함 된 문자열이 있으므로 공백 (ascii 값 32) 처리로 마무리 한다. ascii를 계산하는 핵심 공식을 잘 알아둬야겠다. 1234567891011121314151617181920class Solution { public String solution(String s, int n) { String answer = \"\"; n = n % 26; for (int i=0; i&lt;s.length(); i++){ char ch = s.charAt(i); if (Character.isLowerCase(ch)) { //소문자면 ch = (char)((ch-'a'+n) % 26 + 'a'); //핵심 공식 } else if (Character.isUpperCase(ch)) { //대문자면 ch = (char)((ch-'A'+n) % 26 + 'A'); //핵심 공식 } else if (ch == 32) { //받은 문자가 공백일 때 answer += \"\"; } answer = answer + ch; } return answer; }}","link":"/2020/02/25/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%8B%9C%EC%A0%80-%EC%95%94%ED%98%B8/"},{"title":"[프로그래머스] 순열 검사","text":"배열의 크기가 4면 1부터 4까지 무조건 중복없이 숫자가 들어간다. arr = [4,2,3,1] 하지만 원소의 순서는 뒤죽박죽이 되어 있을 수 있다. 그러므로 java.util.Arrays를 import 하고 매개변수로 들어오는 arr 배열을 sort 시켜준다. 그리고 arr의 index와 index 내부의 원소가 같은 지 판별하는 알고리즘을 짜도록 한다. 12345678910111213141516import java.util.Arrays;class Solution { public boolean solution(int[] arr) { boolean answer = true; Arrays.sort(arr); for (int i=0; i&lt;arr.length; i++){ //배열의 첫번째 방(0번째 방)에 원소 1이 있는지부터 판별 if(arr[i]!=i+1) { answer = false; break; } } return answer; }}","link":"/2020/01/22/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%88%9C%EC%97%B4-%EA%B2%80%EC%82%AC/"},{"title":"[프로그래머스] 자릿 수 더하기","text":"컴퓨터과학 수업에서 새로운 언어를 배울 때 지겹도록 짜본 코드…하지만 간과하지 말자. 이런 간단한 것도 생각이 안날 수 있으니까. 123456789101112import java.util.*;public class Solution { public int solution(int n) { int answer = 0; while (n!=0) { answer += n % 10; n /= 10; } return answer; }}","link":"/2020/01/22/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%9E%90%EB%A6%BF-%EC%88%98-%EB%8D%94%ED%95%98%EA%B8%B0/"},{"title":"[프로그래머스] 직사각형 별 찍기","text":"이중 for문을 잘 이해하라! 12345678910111213141516import java.util.Scanner;public class Solution { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a = sc.nextInt(); int b = sc.nextInt(); for (int i=0; i&lt;b; i++){ for (int j=0; j&lt;a; j++){ System.out.print(\"*\"); } System.out.println(); } }}","link":"/2020/01/26/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%A7%81%EC%82%AC%EA%B0%81%ED%98%95-%EB%B3%84-%EC%B0%8D%EA%B8%B0/"},{"title":"[프로그래머스] 짝수와 홀수","text":"num이 짝수면 Even 홀수면 Odd 123456789101112class Solution { public String solution(int num) { String answer = \"\"; if (num % 2 == 0){ answer = \"Even\"; } else{ answer = \"Odd\"; } return answer; }}","link":"/2020/01/26/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%A7%9D%EC%88%98%EC%99%80-%ED%99%80%EC%88%98/"}],"tags":[{"name":"백준","slug":"백준","link":"/tags/%EB%B0%B1%EC%A4%80/"},{"name":"BOJ","slug":"BOJ","link":"/tags/BOJ/"},{"name":"알고리즘","slug":"알고리즘","link":"/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Stack","slug":"Stack","link":"/tags/Stack/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Blog","slug":"Blog","link":"/tags/Blog/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"plugin","slug":"plugin","link":"/tags/plugin/"},{"name":"SEO","slug":"SEO","link":"/tags/SEO/"},{"name":"조회수","slug":"조회수","link":"/tags/%EC%A1%B0%ED%9A%8C%EC%88%98/"},{"name":"방문자수","slug":"방문자수","link":"/tags/%EB%B0%A9%EB%AC%B8%EC%9E%90%EC%88%98/"},{"name":"프로그래머스","slug":"프로그래머스","link":"/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"정렬","slug":"정렬","link":"/tags/%EC%A0%95%EB%A0%AC/"},{"name":"sort","slug":"sort","link":"/tags/sort/"},{"name":"copyOfRange()","slug":"copyOfRange","link":"/tags/copyOfRange/"},{"name":"ascii","slug":"ascii","link":"/tags/ascii/"},{"name":"atoi","slug":"atoi","link":"/tags/atoi/"},{"name":"long","slug":"long","link":"/tags/long/"},{"name":"integer","slug":"integer","link":"/tags/integer/"},{"name":"equals()","slug":"equals","link":"/tags/equals/"},{"name":"==","slug":"","link":"/tags/"},{"name":"parse","slug":"parse","link":"/tags/parse/"},{"name":"isLowerCase()","slug":"isLowerCase","link":"/tags/isLowerCase/"},{"name":"isUpperCase()","slug":"isUpperCase","link":"/tags/isUpperCase/"}],"categories":[{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"Programmers","slug":"Algorithm/Programmers","link":"/categories/Algorithm/Programmers/"},{"name":"BOJ","slug":"Algorithm/BOJ","link":"/categories/Algorithm/BOJ/"}]}